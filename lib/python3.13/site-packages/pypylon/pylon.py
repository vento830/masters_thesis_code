# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""

Copyright (C) 2017-2023 Basler AG
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
    1. Redistributions of source code must retain the above copyright notice,
       this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    3. Neither the name of the copyright holder nor the names of its contributors
       may be used to endorse or promote products derived from this software
       without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pylon
else:
    import _pylon

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_SwigPyIterator

    def value(self):
        return _pylon.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pylon.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pylon.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pylon.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pylon.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pylon.SwigPyIterator_copy(self)

    def next(self):
        return _pylon.SwigPyIterator_next(self)

    def __next__(self):
        return _pylon.SwigPyIterator___next__(self)

    def previous(self):
        return _pylon.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pylon.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pylon.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pylon.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pylon.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pylon.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pylon.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pylon.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pylon:
_pylon.SwigPyIterator_swigregister(SwigPyIterator)

try:
  from types import ModuleType
  import numpy as _pylon_numpy
except:
  pass

import warnings
def needs_numpy(func):
 def func_wrapper(*args, **kwargs):
    e = None
    try:
      if not isinstance(_pylon_numpy, ModuleType):
        e = RuntimeError("_pylon_numpy not a module - not good!")
    except NameError:
      e = NotImplementedError("please install numpy to use this method")
    if e: raise e
    return func(*args, **kwargs)
 return func_wrapper

import pypylon.genicam
PYLON_VERSION_MAJOR = _pylon.PYLON_VERSION_MAJOR
PYLON_VERSION_MINOR = _pylon.PYLON_VERSION_MINOR
PYLON_VERSION_SUBMINOR = _pylon.PYLON_VERSION_SUBMINOR
PYLON_VERSION_BUILD = _pylon.PYLON_VERSION_BUILD
PYLON_VERSIONSTRING_MAJOR = _pylon.PYLON_VERSIONSTRING_MAJOR
PYLON_VERSIONSTRING_MINOR = _pylon.PYLON_VERSIONSTRING_MINOR
PYLON_VERSIONSTRING_SUBMINOR = _pylon.PYLON_VERSIONSTRING_SUBMINOR
PYLON_VERSIONSTRING_BUILD = _pylon.PYLON_VERSIONSTRING_BUILD
PYLON_VERSIONSTRING_EXTENSION = _pylon.PYLON_VERSIONSTRING_EXTENSION
class VersionInfo(object):
    r"""


    Holds a four-part version number consisting of major.minor.subminor.build.  

    This class stores a four-part version number and provides comparison operators.
    If you use the constructor with one parameter, the version info object will be
    initialized with pylon base version numbers.  

    You can also call the static getVersionString() method to retrieve a string
    containing the complete version separated by dots.  

    C++ includes: PylonVersionInfo.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Constructs a version info object using the version number parts passed.  

        """
        _pylon.VersionInfo_swiginit(self, _pylon.new_VersionInfo(*args))
    __swig_destroy__ = _pylon.delete_VersionInfo

    def getMajor(self):
        r"""


        Returns the major version number. For version 2.1.3.1234 the value 2 would be
        returned.  

        """
        return _pylon.VersionInfo_getMajor(self)

    def getMinor(self):
        r"""


        Returns the minor version number. For version 2.1.3.1234 the value 1 would be
        returned.  

        """
        return _pylon.VersionInfo_getMinor(self)

    def getSubminor(self):
        r"""


        Returns the subminor version number. For version 2.1.3.1234 the value 3 would be
        returned.  

        """
        return _pylon.VersionInfo_getSubminor(self)

    def getBuild(self):
        r"""


        Returns the build number. For version 2.1.3.1234 the value 1234 would be
        returned.  

        """
        return _pylon.VersionInfo_getBuild(self)

    def __gt__(self, rhs):
        return _pylon.VersionInfo___gt__(self, rhs)

    def __eq__(self, rhs):
        return _pylon.VersionInfo___eq__(self, rhs)

    def __ge__(self, rhs):
        return _pylon.VersionInfo___ge__(self, rhs)

    def __lt__(self, rhs):
        return _pylon.VersionInfo___lt__(self, rhs)

    def __ne__(self, rhs):
        return _pylon.VersionInfo___ne__(self, rhs)

    def __le__(self, rhs):
        return _pylon.VersionInfo___le__(self, rhs)

    def __repr__(self):
        return f"<VersionInfo {self.getMajor()}.{self.getMinor()}.{self.getSubminor()}>"


# Register VersionInfo in _pylon:
_pylon.VersionInfo_swigregister(VersionInfo)

GenericException = pypylon.genicam.GenericException
BadAllocException = pypylon.genicam.BadAllocException
InvalidArgumentException = pypylon.genicam.InvalidArgumentException
OutOfRangeException = pypylon.genicam.OutOfRangeException
PropertyException = pypylon.genicam.PropertyException
RuntimeException = pypylon.genicam.RuntimeException
LogicalErrorException = pypylon.genicam.LogicalErrorException
AccessException = pypylon.genicam.AccessException
TimeoutException = pypylon.genicam.TimeoutException
DynamicCastException = pypylon.genicam.DynamicCastException

PIXEL_MONO = _pylon.PIXEL_MONO
PIXEL_COLOR = _pylon.PIXEL_COLOR
PIXEL_CUSTOMTYPE = _pylon.PIXEL_CUSTOMTYPE
PixelType_Undefined = _pylon.PixelType_Undefined
PixelType_Mono1packed = _pylon.PixelType_Mono1packed
PixelType_Mono2packed = _pylon.PixelType_Mono2packed
PixelType_Mono4packed = _pylon.PixelType_Mono4packed
PixelType_Mono8 = _pylon.PixelType_Mono8
PixelType_Mono8signed = _pylon.PixelType_Mono8signed
PixelType_Mono10 = _pylon.PixelType_Mono10
PixelType_Mono10packed = _pylon.PixelType_Mono10packed
PixelType_Mono10p = _pylon.PixelType_Mono10p
PixelType_Mono12 = _pylon.PixelType_Mono12
PixelType_Mono12packed = _pylon.PixelType_Mono12packed
PixelType_Mono12p = _pylon.PixelType_Mono12p
PixelType_Mono16 = _pylon.PixelType_Mono16
PixelType_BayerGR8 = _pylon.PixelType_BayerGR8
PixelType_BayerRG8 = _pylon.PixelType_BayerRG8
PixelType_BayerGB8 = _pylon.PixelType_BayerGB8
PixelType_BayerBG8 = _pylon.PixelType_BayerBG8
PixelType_BayerGR10 = _pylon.PixelType_BayerGR10
PixelType_BayerRG10 = _pylon.PixelType_BayerRG10
PixelType_BayerGB10 = _pylon.PixelType_BayerGB10
PixelType_BayerBG10 = _pylon.PixelType_BayerBG10
PixelType_BayerGR12 = _pylon.PixelType_BayerGR12
PixelType_BayerRG12 = _pylon.PixelType_BayerRG12
PixelType_BayerGB12 = _pylon.PixelType_BayerGB12
PixelType_BayerBG12 = _pylon.PixelType_BayerBG12
PixelType_RGB8packed = _pylon.PixelType_RGB8packed
PixelType_BGR8packed = _pylon.PixelType_BGR8packed
PixelType_RGBA8packed = _pylon.PixelType_RGBA8packed
PixelType_BGRA8packed = _pylon.PixelType_BGRA8packed
PixelType_RGB10packed = _pylon.PixelType_RGB10packed
PixelType_BGR10packed = _pylon.PixelType_BGR10packed
PixelType_RGB12packed = _pylon.PixelType_RGB12packed
PixelType_BGR12packed = _pylon.PixelType_BGR12packed
PixelType_RGB16packed = _pylon.PixelType_RGB16packed
PixelType_BGR10V1packed = _pylon.PixelType_BGR10V1packed
PixelType_BGR10V2packed = _pylon.PixelType_BGR10V2packed
PixelType_YUV411packed = _pylon.PixelType_YUV411packed
PixelType_YUV422packed = _pylon.PixelType_YUV422packed
PixelType_YUV444packed = _pylon.PixelType_YUV444packed
PixelType_RGB8planar = _pylon.PixelType_RGB8planar
PixelType_RGB10planar = _pylon.PixelType_RGB10planar
PixelType_RGB12planar = _pylon.PixelType_RGB12planar
PixelType_RGB16planar = _pylon.PixelType_RGB16planar
PixelType_YUV422_YUYV_Packed = _pylon.PixelType_YUV422_YUYV_Packed
PixelType_YUV444planar = _pylon.PixelType_YUV444planar
PixelType_YUV422planar = _pylon.PixelType_YUV422planar
PixelType_YUV420planar = _pylon.PixelType_YUV420planar
PixelType_YCbCr420_8_YY_CbCr_Semiplanar = _pylon.PixelType_YCbCr420_8_YY_CbCr_Semiplanar
PixelType_YCbCr422_8_YY_CbCr_Semiplanar = _pylon.PixelType_YCbCr422_8_YY_CbCr_Semiplanar
PixelType_BayerGR12Packed = _pylon.PixelType_BayerGR12Packed
PixelType_BayerRG12Packed = _pylon.PixelType_BayerRG12Packed
PixelType_BayerGB12Packed = _pylon.PixelType_BayerGB12Packed
PixelType_BayerBG12Packed = _pylon.PixelType_BayerBG12Packed
PixelType_BayerGR10p = _pylon.PixelType_BayerGR10p
PixelType_BayerRG10p = _pylon.PixelType_BayerRG10p
PixelType_BayerGB10p = _pylon.PixelType_BayerGB10p
PixelType_BayerBG10p = _pylon.PixelType_BayerBG10p
PixelType_BayerGR12p = _pylon.PixelType_BayerGR12p
PixelType_BayerRG12p = _pylon.PixelType_BayerRG12p
PixelType_BayerGB12p = _pylon.PixelType_BayerGB12p
PixelType_BayerBG12p = _pylon.PixelType_BayerBG12p
PixelType_BayerGR16 = _pylon.PixelType_BayerGR16
PixelType_BayerRG16 = _pylon.PixelType_BayerRG16
PixelType_BayerGB16 = _pylon.PixelType_BayerGB16
PixelType_BayerBG16 = _pylon.PixelType_BayerBG16
PixelType_RGB12V1packed = _pylon.PixelType_RGB12V1packed
PixelType_Double = _pylon.PixelType_Double
PixelType_Confidence8 = _pylon.PixelType_Confidence8
PixelType_Confidence16 = _pylon.PixelType_Confidence16
PixelType_Coord3D_C8 = _pylon.PixelType_Coord3D_C8
PixelType_Coord3D_C16 = _pylon.PixelType_Coord3D_C16
PixelType_Coord3D_ABC32f = _pylon.PixelType_Coord3D_ABC32f
PixelType_Data8 = _pylon.PixelType_Data8
PixelType_Data8s = _pylon.PixelType_Data8s
PixelType_Data16 = _pylon.PixelType_Data16
PixelType_Data16s = _pylon.PixelType_Data16s
PixelType_Data32 = _pylon.PixelType_Data32
PixelType_Data32s = _pylon.PixelType_Data32s
PixelType_Data64 = _pylon.PixelType_Data64
PixelType_Data64s = _pylon.PixelType_Data64s
PixelType_Data32f = _pylon.PixelType_Data32f
PixelType_Data64f = _pylon.PixelType_Data64f

def IsMonoPacked(pixelType):
    return _pylon.IsMonoPacked(pixelType)

def IsBayerPacked(pixelType):
    return _pylon.IsBayerPacked(pixelType)

def IsRGBPacked(pixelType):
    return _pylon.IsRGBPacked(pixelType)

def IsBGRPacked(pixelType):
    return _pylon.IsBGRPacked(pixelType)

def IsPacked(pixelType):
    return _pylon.IsPacked(pixelType)

def IsPackedInLsbFormat(pixelType):
    return _pylon.IsPackedInLsbFormat(pixelType)

def PlaneCount(pixelType):
    return _pylon.PlaneCount(pixelType)

def GetPlanePixelType(pixelType):
    return _pylon.GetPlanePixelType(pixelType)

def IsPlanar(pixelType):
    return _pylon.IsPlanar(pixelType)

def IsYUVSemiplanar(pixelType):
    return _pylon.IsYUVSemiplanar(pixelType)
PCF_BayerRG = _pylon.PCF_BayerRG
PCF_BayerGB = _pylon.PCF_BayerGB
PCF_BayerGR = _pylon.PCF_BayerGR
PCF_BayerBG = _pylon.PCF_BayerBG
PCF_Undefined = _pylon.PCF_Undefined

def GetPixelColorFilter(pixelType):
    return _pylon.GetPixelColorFilter(pixelType)

def BitPerPixel(pixelType):
    return _pylon.BitPerPixel(pixelType)

def SamplesPerPixel(pixelType):
    return _pylon.SamplesPerPixel(pixelType)

def IsYUV(pixelType):
    return _pylon.IsYUV(pixelType)

def IsRGBA(pixelType):
    return _pylon.IsRGBA(pixelType)

def IsRGB(pixelType):
    return _pylon.IsRGB(pixelType)

def IsBGRA(pixelType):
    return _pylon.IsBGRA(pixelType)

def IsBGR(pixelType):
    return _pylon.IsBGR(pixelType)

def IsBayer(pixelType):
    return _pylon.IsBayer(pixelType)

def IsMono(pixelType):
    return _pylon.IsMono(pixelType)

def IsMonoImage(pixelType):
    return _pylon.IsMonoImage(pixelType)

def IsColorImage(pixelType):
    return _pylon.IsColorImage(pixelType)

def HasAlpha(pixelType):
    return _pylon.HasAlpha(pixelType)

def IsFloatingPoint(pixelType):
    return _pylon.IsFloatingPoint(pixelType)

def GetPixelIncrementX(pixelType):
    return _pylon.GetPixelIncrementX(pixelType)

def GetPixelIncrementY(pixelType):
    return _pylon.GetPixelIncrementY(pixelType)

def BitDepth(pixelType):
    return _pylon.BitDepth(pixelType)

def ComputeStride(strideBytes, pixelType, width, paddingX=0):
    return _pylon.ComputeStride(strideBytes, pixelType, width, paddingX)

def ComputePaddingX(strideBytes, pixelType, width):
    return _pylon.ComputePaddingX(strideBytes, pixelType, width)

def ComputeBufferSize(pixelType, width, height, paddingX=0):
    return _pylon.ComputeBufferSize(pixelType, width, height, paddingX)

def GetPixelTypesForUnpacking(pixelTypeSource, pixelTypeToImpose, pixelTypeTarget):
    return _pylon.GetPixelTypesForUnpacking(pixelTypeSource, pixelTypeToImpose, pixelTypeTarget)
PayloadType_Undefined = _pylon.PayloadType_Undefined
PayloadType_Image = _pylon.PayloadType_Image
PayloadType_RawData = _pylon.PayloadType_RawData
PayloadType_File = _pylon.PayloadType_File
PayloadType_ChunkData = _pylon.PayloadType_ChunkData
PayloadType_GenDC = _pylon.PayloadType_GenDC
PayloadType_DeviceSpecific = _pylon.PayloadType_DeviceSpecific
class IProperties(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetPropertyNames(self):
        return _pylon.IProperties_GetPropertyNames(self)

    def GetPropertyAvailable(self, Name):
        return _pylon.IProperties_GetPropertyAvailable(self, Name)

    def GetPropertyValue(self, Name):
        return _pylon.IProperties_GetPropertyValue(self, Name)

    def SetPropertyValue(self, Name, Value):
        return _pylon.IProperties_SetPropertyValue(self, Name, Value)

    def IsSubset(self, Subset):
        return _pylon.IProperties_IsSubset(self, Subset)

# Register IProperties in _pylon:
_pylon.IProperties_swigregister(IProperties)
class CInfoBase(IProperties):
    r"""


    Base implementation for PYLON info container.  

    Info container allow a generic access to implemented properties. All Properties
    and their values can be accessed without knowing them in advance. It is possible
    to enumerate all properties available and corresponding values. Properties and
    values are represented as String_t. The normal usage is to have enumerators that
    create the info objects and clients that read only.  

    If the type of the info object is known before client can use specific accessor
    function to retrieve the property values  

    C++ includes: Info.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __eq__(self, rhs):
        return _pylon.CInfoBase___eq__(self, rhs)

    def __lt__(self, rhs):
        return _pylon.CInfoBase___lt__(self, rhs)

    def GetFriendlyName(self):
        r"""


        Retrieves the human readable name of the device. This property is identified by
        Key::FriendlyNameKey.  

        """
        return _pylon.CInfoBase_GetFriendlyName(self)

    def SetFriendlyName(self, FriendlyNameValue):
        r"""


        Sets the above property.  

        """
        return _pylon.CInfoBase_SetFriendlyName(self, FriendlyNameValue)

    def IsFriendlyNameAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.CInfoBase_IsFriendlyNameAvailable(self)

    def GetFullName(self):
        r"""


        Retrieves the full name identifying the device. This property is identified by
        Key::FullNameKey.  

        """
        return _pylon.CInfoBase_GetFullName(self)

    def SetFullName(self, FullNameValue):
        r"""


        Sets the above property.  

        """
        return _pylon.CInfoBase_SetFullName(self, FullNameValue)

    def IsFullNameAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.CInfoBase_IsFullNameAvailable(self)

    def GetVendorName(self):
        r"""


        Retrieves the vendor name of the device. This property is identified by
        Key::VendorNameKey.  

        """
        return _pylon.CInfoBase_GetVendorName(self)

    def SetVendorName(self, VendorNameValue):
        r"""


        Sets the above property.  

        """
        return _pylon.CInfoBase_SetVendorName(self, VendorNameValue)

    def IsVendorNameAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.CInfoBase_IsVendorNameAvailable(self)

    def GetDeviceClass(self):
        r"""


        Retrieves the device class device, e.g. Basler1394. This property is identified
        by Key::DeviceClassKey.  

        """
        return _pylon.CInfoBase_GetDeviceClass(self)

    def SetDeviceClass(self, DeviceClassValue):
        r"""


        Sets the above property.  

        """
        return _pylon.CInfoBase_SetDeviceClass(self, DeviceClassValue)

    def IsDeviceClassAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.CInfoBase_IsDeviceClassAvailable(self)

    def GetTLType(self):
        return _pylon.CInfoBase_GetTLType(self)

    def SetTLType(self, value):
        return _pylon.CInfoBase_SetTLType(self, value)

    def IsTLTypeAvailable(self):
        return _pylon.CInfoBase_IsTLTypeAvailable(self)

    @staticmethod
    def GetPropertyNotAvailable():
        r"""


        """
        return _pylon.CInfoBase_GetPropertyNotAvailable()

    def GetPropertyNames(self):
        r"""


        """
        return _pylon.CInfoBase_GetPropertyNames(self)

    def GetPropertyAvailable(self, Name):
        r"""


        """
        return _pylon.CInfoBase_GetPropertyAvailable(self, Name)

    def GetPropertyValue(self, Name):
        r"""


        """
        return _pylon.CInfoBase_GetPropertyValue(self, Name)

    def SetPropertyValue(self, Name, Value):
        r"""


        """
        return _pylon.CInfoBase_SetPropertyValue(self, Name, Value)

    def IsUserProvided(self):
        r"""


        """
        return _pylon.CInfoBase_IsUserProvided(self)

    def IsSubset(self, Subset):
        r"""


        """
        return _pylon.CInfoBase_IsSubset(self, Subset)

# Register CInfoBase in _pylon:
_pylon.CInfoBase_swigregister(CInfoBase)
cvar = _pylon.cvar
TLTypeGigE = cvar.TLTypeGigE
TLTypeUSB = cvar.TLTypeUSB
TLTypeCL = cvar.TLTypeCL
TLTypeCamEmu = cvar.TLTypeCamEmu
TLTypeIPCam = cvar.TLTypeIPCam
TLTypeCXP = cvar.TLTypeCXP
TLTypeCustom = cvar.TLTypeCustom
FriendlyNameKey = cvar.FriendlyNameKey
FullNameKey = cvar.FullNameKey
VendorNameKey = cvar.VendorNameKey
DeviceClassKey = cvar.DeviceClassKey
TLTypeKey = cvar.TLTypeKey
InterfaceIDKey = cvar.InterfaceIDKey
CInfoBase.PropertyNotAvailable = _pylon.cvar.CInfoBase_PropertyNotAvailable

class DeviceInfo(CInfoBase):
    r"""


    Holds information about an enumerated device.  

    The device enumeration process creates a list of CDeviceInfo objects
    (Pylon::DeviceInfoList_t). Each CDeviceInfo objects stores information about a
    device. The information is retrieved during the device enumeration process
    (ITransportLayer::EnumerateDevices resp. CTlFactory::EnumerateDevices)  

    C++ includes: DeviceInfo.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        """
        _pylon.DeviceInfo_swiginit(self, _pylon.new_DeviceInfo(*args))
    __swig_destroy__ = _pylon.delete_DeviceInfo

    def __lt__(self, rhs):
        return _pylon.DeviceInfo___lt__(self, rhs)

    def GetSerialNumber(self):
        r"""


        Retrieves the serial number if it supported by the underlying implementation
        This property is identified by Key::SerialNumberKey.  

        """
        return _pylon.DeviceInfo_GetSerialNumber(self)

    def SetSerialNumber(self, SerialNumberValue):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetSerialNumber(self, SerialNumberValue)

    def IsSerialNumberAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsSerialNumberAvailable(self)

    def GetUserDefinedName(self):
        r"""


        Retrieves the user-defined name if present. This property is identified by
        Key::UserDefinedNameKey.  

        """
        return _pylon.DeviceInfo_GetUserDefinedName(self)

    def SetUserDefinedName(self, UserDefinedNameValue):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetUserDefinedName(self, UserDefinedNameValue)

    def IsUserDefinedNameAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsUserDefinedNameAvailable(self)

    def GetModelName(self):
        r"""


        Retrieves the model name of the device. This property is identified by
        Key::ModelNameKey.  

        """
        return _pylon.DeviceInfo_GetModelName(self)

    def SetModelName(self, ModelNameValue):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetModelName(self, ModelNameValue)

    def IsModelNameAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsModelNameAvailable(self)

    def GetDeviceVersion(self):
        r"""


        Retrieves the version string of the device. This property is identified by
        Key::DeviceVersionKey.  

        """
        return _pylon.DeviceInfo_GetDeviceVersion(self)

    def SetDeviceVersion(self, DeviceVersionValue):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetDeviceVersion(self, DeviceVersionValue)

    def IsDeviceVersionAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsDeviceVersionAvailable(self)

    def GetDeviceFactory(self):
        r"""


        Retrieves the identifier for the transport layer able to create this device.
        This property is identified by Key::DeviceFactoryKey.  

        """
        return _pylon.DeviceInfo_GetDeviceFactory(self)

    def SetDeviceFactory(self, DeviceFactoryValue):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetDeviceFactory(self, DeviceFactoryValue)

    def IsDeviceFactoryAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsDeviceFactoryAvailable(self)

    def GetXMLSource(self):
        r"""


        Retrieves the location where the XML file was loaded from. This property is
        identified by Key::XMLSourceKey. You must use the DeviceInfo of an opened
        IPylonDevice to retrieve this property.  

        """
        return _pylon.DeviceInfo_GetXMLSource(self)

    def SetXMLSource(self, XMLSource):
        r"""


        Sets the above property.  

        """
        return _pylon.DeviceInfo_SetXMLSource(self, XMLSource)

    def IsXMLSourceAvailable(self):
        r"""


        Returns true if the above property is available.  

        """
        return _pylon.DeviceInfo_IsXMLSourceAvailable(self)

    def SetFriendlyName(self, FriendlyNameValue):
        r"""


        Sets the display friendly name of the device. This property is identified by
        Key::FriendlyNameKey. This method overrides a method of a base class returning a
        reference to CDeviceInfo  

        """
        return _pylon.DeviceInfo_SetFriendlyName(self, FriendlyNameValue)

    def SetFullName(self, FullNameValue):
        r"""


        Sets the full name identifying the device. This property is identified by
        Key::FullNameKey. This method overrides a method of a base class returning a
        reference to CDeviceInfo  

        """
        return _pylon.DeviceInfo_SetFullName(self, FullNameValue)

    def SetVendorName(self, VendorNameValue):
        r"""


        Sets the vendor name of the device. This property is identified by
        Key::VendorNameKey. This method overrides a method of a base class returning a
        reference to CDeviceInfo  

        """
        return _pylon.DeviceInfo_SetVendorName(self, VendorNameValue)

    def SetDeviceClass(self, DeviceClassValue):
        r"""


        Sets the device class device, e.g. Basler1394. This property is identified by
        Key::DeviceClassKey. This method overrides a method of a base class returning a
        reference to CDeviceInfo  

        """
        return _pylon.DeviceInfo_SetDeviceClass(self, DeviceClassValue)

    def GetInterfaceID(self):
        return _pylon.DeviceInfo_GetInterfaceID(self)

    def SetInterfaceID(self, InterfaceIDValue):
        return _pylon.DeviceInfo_SetInterfaceID(self, InterfaceIDValue)

    def IsInterfaceIDAvailable(self):
        return _pylon.DeviceInfo_IsInterfaceIDAvailable(self)

    def GetAddress(self):
        return _pylon.DeviceInfo_GetAddress(self)

    def SetAddress(self, AddressValue):
        return _pylon.DeviceInfo_SetAddress(self, AddressValue)

    def IsAddressAvailable(self):
        return _pylon.DeviceInfo_IsAddressAvailable(self)

    def GetIpAddress(self):
        return _pylon.DeviceInfo_GetIpAddress(self)

    def SetIpAddress(self, IpAddressValue):
        return _pylon.DeviceInfo_SetIpAddress(self, IpAddressValue)

    def IsIpAddressAvailable(self):
        return _pylon.DeviceInfo_IsIpAddressAvailable(self)

    def GetSubnetAddress(self):
        return _pylon.DeviceInfo_GetSubnetAddress(self)

    def SetSubnetAddress(self, SubnetAddressValue):
        return _pylon.DeviceInfo_SetSubnetAddress(self, SubnetAddressValue)

    def IsSubnetAddressAvailable(self):
        return _pylon.DeviceInfo_IsSubnetAddressAvailable(self)

    def GetDefaultGateway(self):
        return _pylon.DeviceInfo_GetDefaultGateway(self)

    def SetDefaultGateway(self, DefaultGatewayValue):
        return _pylon.DeviceInfo_SetDefaultGateway(self, DefaultGatewayValue)

    def IsDefaultGatewayAvailable(self):
        return _pylon.DeviceInfo_IsDefaultGatewayAvailable(self)

    def GetSubnetMask(self):
        return _pylon.DeviceInfo_GetSubnetMask(self)

    def SetSubnetMask(self, SubnetMaskValue):
        return _pylon.DeviceInfo_SetSubnetMask(self, SubnetMaskValue)

    def IsSubnetMaskAvailable(self):
        return _pylon.DeviceInfo_IsSubnetMaskAvailable(self)

    def GetPortNr(self):
        return _pylon.DeviceInfo_GetPortNr(self)

    def SetPortNr(self, PortNrValue):
        return _pylon.DeviceInfo_SetPortNr(self, PortNrValue)

    def IsPortNrAvailable(self):
        return _pylon.DeviceInfo_IsPortNrAvailable(self)

    def GetMacAddress(self):
        return _pylon.DeviceInfo_GetMacAddress(self)

    def SetMacAddress(self, MacAddressValue):
        return _pylon.DeviceInfo_SetMacAddress(self, MacAddressValue)

    def IsMacAddressAvailable(self):
        return _pylon.DeviceInfo_IsMacAddressAvailable(self)

    def GetInterface(self):
        return _pylon.DeviceInfo_GetInterface(self)

    def SetInterface(self, InterfaceValue):
        return _pylon.DeviceInfo_SetInterface(self, InterfaceValue)

    def IsInterfaceAvailable(self):
        return _pylon.DeviceInfo_IsInterfaceAvailable(self)

    def GetIpConfigOptions(self):
        return _pylon.DeviceInfo_GetIpConfigOptions(self)

    def SetIpConfigOptions(self, IpConfigOptionsValue):
        return _pylon.DeviceInfo_SetIpConfigOptions(self, IpConfigOptionsValue)

    def IsIpConfigOptionsAvailable(self):
        return _pylon.DeviceInfo_IsIpConfigOptionsAvailable(self)

    def GetIpConfigCurrent(self):
        return _pylon.DeviceInfo_GetIpConfigCurrent(self)

    def SetIpConfigCurrent(self, IpConfigCurrentValue):
        return _pylon.DeviceInfo_SetIpConfigCurrent(self, IpConfigCurrentValue)

    def IsIpConfigCurrentAvailable(self):
        return _pylon.DeviceInfo_IsIpConfigCurrentAvailable(self)

    def GetDeviceGUID(self):
        return _pylon.DeviceInfo_GetDeviceGUID(self)

    def IsDeviceGUIDAvailable(self):
        return _pylon.DeviceInfo_IsDeviceGUIDAvailable(self)

    def GetManufacturerInfo(self):
        return _pylon.DeviceInfo_GetManufacturerInfo(self)

    def IsManufacturerInfoAvailable(self):
        return _pylon.DeviceInfo_IsManufacturerInfoAvailable(self)

    def GetDeviceIdx(self):
        return _pylon.DeviceInfo_GetDeviceIdx(self)

    def IsDeviceIdxAvailable(self):
        return _pylon.DeviceInfo_IsDeviceIdxAvailable(self)

    def GetProductId(self):
        return _pylon.DeviceInfo_GetProductId(self)

    def IsProductIdAvailable(self):
        return _pylon.DeviceInfo_IsProductIdAvailable(self)

    def GetVendorId(self):
        return _pylon.DeviceInfo_GetVendorId(self)

    def IsVendorIdAvailable(self):
        return _pylon.DeviceInfo_IsVendorIdAvailable(self)

    def GetDriverKeyName(self):
        return _pylon.DeviceInfo_GetDriverKeyName(self)

    def IsDriverKeyNameAvailable(self):
        return _pylon.DeviceInfo_IsDriverKeyNameAvailable(self)

    def GetUsbDriverType(self):
        return _pylon.DeviceInfo_GetUsbDriverType(self)

    def IsUsbDriverTypeAvailable(self):
        return _pylon.DeviceInfo_IsUsbDriverTypeAvailable(self)

    def GetTransferMode(self):
        return _pylon.DeviceInfo_GetTransferMode(self)

    def IsTransferModeAvailable(self):
        return _pylon.DeviceInfo_IsTransferModeAvailable(self)

    def GetPortID(self):
        return _pylon.DeviceInfo_GetPortID(self)

    def SetPortID(self, PortIDValue):
        return _pylon.DeviceInfo_SetPortID(self, PortIDValue)

    def IsPortIDAvailable(self):
        return _pylon.DeviceInfo_IsPortIDAvailable(self)

    def GetDeviceID(self):
        return _pylon.DeviceInfo_GetDeviceID(self)

    def SetDeviceID(self, DeviceIDValue):
        return _pylon.DeviceInfo_SetDeviceID(self, DeviceIDValue)

    def IsDeviceIDAvailable(self):
        return _pylon.DeviceInfo_IsDeviceIDAvailable(self)

    def GetInitialBaudRate(self):
        return _pylon.DeviceInfo_GetInitialBaudRate(self)

    def SetInitialBaudRate(self, InitialBaudRateValue):
        return _pylon.DeviceInfo_SetInitialBaudRate(self, InitialBaudRateValue)

    def IsInitialBaudRateAvailable(self):
        return _pylon.DeviceInfo_IsInitialBaudRateAvailable(self)

    def GetDeviceXMLFileOverride(self):
        return _pylon.DeviceInfo_GetDeviceXMLFileOverride(self)

    def SetDeviceXMLFileOverride(self, DeviceXMLFileOverrideValue):
        return _pylon.DeviceInfo_SetDeviceXMLFileOverride(self, DeviceXMLFileOverrideValue)

    def IsDeviceXMLFileOverrideAvailable(self):
        return _pylon.DeviceInfo_IsDeviceXMLFileOverrideAvailable(self)

    def GetDeviceSpecificString(self):
        return _pylon.DeviceInfo_GetDeviceSpecificString(self)

    def SetDeviceSpecificString(self, DeviceSpecificStringValue):
        return _pylon.DeviceInfo_SetDeviceSpecificString(self, DeviceSpecificStringValue)

    def IsDeviceSpecificStringAvailable(self):
        return _pylon.DeviceInfo_IsDeviceSpecificStringAvailable(self)

    def GetPortSpecificString(self):
        return _pylon.DeviceInfo_GetPortSpecificString(self)

    def SetPortSpecificString(self, PortSpecificStringValue):
        return _pylon.DeviceInfo_SetPortSpecificString(self, PortSpecificStringValue)

    def IsPortSpecificStringAvailable(self):
        return _pylon.DeviceInfo_IsPortSpecificStringAvailable(self)

    def SetPropertyValue(self, Name, Value):
        r"""


        Modifies a property value This method overrides a method of a base class
        returning a reference to CDeviceInfo  

        """
        return _pylon.DeviceInfo_SetPropertyValue(self, Name, Value)

    def IsPersistentIpActive(self):
        return _pylon.DeviceInfo_IsPersistentIpActive(self)

    def IsDhcpActive(self):
        return _pylon.DeviceInfo_IsDhcpActive(self)

    def IsAutoIpActive(self):
        return _pylon.DeviceInfo_IsAutoIpActive(self)

    def IsPersistentIpSupported(self):
        return _pylon.DeviceInfo_IsPersistentIpSupported(self)

    def IsDhcpSupported(self):
        return _pylon.DeviceInfo_IsDhcpSupported(self)

    def IsAutoIpSupported(self):
        return _pylon.DeviceInfo_IsAutoIpSupported(self)

    def IsSubset(self, Subset):
        r"""


        """
        return _pylon.DeviceInfo_IsSubset(self, Subset)

# Register DeviceInfo in _pylon:
_pylon.DeviceInfo_swigregister(DeviceInfo)
SerialNumberKey = cvar.SerialNumberKey
UserDefinedNameKey = cvar.UserDefinedNameKey
ModelNameKey = cvar.ModelNameKey
DeviceVersionKey = cvar.DeviceVersionKey
DeviceFactoryKey = cvar.DeviceFactoryKey
XMLSourceKey = cvar.XMLSourceKey
ManufacturerInfoKey = cvar.ManufacturerInfoKey
DeviceIDKey = cvar.DeviceIDKey
AddressKey = cvar.AddressKey
IpAddressKey = cvar.IpAddressKey
DefaultGatewayKey = cvar.DefaultGatewayKey
SubnetMaskKey = cvar.SubnetMaskKey
SubnetAddressKey = cvar.SubnetAddressKey
PortNrKey = cvar.PortNrKey
MacAddressKey = cvar.MacAddressKey
InterfaceKey = cvar.InterfaceKey
IpConfigOptionsKey = cvar.IpConfigOptionsKey
IpConfigCurrentKey = cvar.IpConfigCurrentKey
DeviceGUIDKey = cvar.DeviceGUIDKey
VendorIdKey = cvar.VendorIdKey
ProductIdKey = cvar.ProductIdKey
DriverKeyNameKey = cvar.DriverKeyNameKey
UsbDriverTypeKey = cvar.UsbDriverTypeKey
UsbPortVersionBcdKey = cvar.UsbPortVersionBcdKey
SpeedSupportBitmaskKey = cvar.SpeedSupportBitmaskKey
TransferModeKey = cvar.TransferModeKey
PortIDKey = cvar.PortIDKey
InitialBaudRateKey = cvar.InitialBaudRateKey
DeviceXMLFileOverrideKey = cvar.DeviceXMLFileOverrideKey
DeviceSpecificStringKey = cvar.DeviceSpecificStringKey
PortSpecificStringKey = cvar.PortSpecificStringKey


CDeviceInfo = DeviceInfo

class InterfaceInfo(CInfoBase):
    r"""


    Class used for storing information about an interface object provided by a
    transport layer.  

    Enumerating the available Transport Layer Interface objects returns a list of
    CInterface objects (Pylon::InterfaceInfoList_t). A CInterfaceInfo object holds
    information about the enumerated interface.  

    C++ includes: InterfaceInfo.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pylon.InterfaceInfo_swiginit(self, _pylon.new_InterfaceInfo(*args))
    __swig_destroy__ = _pylon.delete_InterfaceInfo

    def __lt__(self, rhs):
        return _pylon.InterfaceInfo___lt__(self, rhs)

    def GetInterfaceID(self):
        return _pylon.InterfaceInfo_GetInterfaceID(self)

    def SetInterfaceID(self, InterfaceIDValue):
        return _pylon.InterfaceInfo_SetInterfaceID(self, InterfaceIDValue)

    def IsInterfaceIDAvailable(self):
        return _pylon.InterfaceInfo_IsInterfaceIDAvailable(self)

# Register InterfaceInfo in _pylon:
_pylon.InterfaceInfo_swigregister(InterfaceInfo)
class TlInfo(CInfoBase):
    r"""


    Class used for storing the result of the transport layer enumeration process.  

    Enumerating the available Transport Layer objects returns a list of CTlInfo
    objects (Pylon::TlInfoList_t). A CTlInfo object holds information about the
    enumerated transport layer.  

    C++ includes: TlInfo.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def GetFileName(self):
        return _pylon.TlInfo_GetFileName(self)

    def SetFileName(self, value):
        return _pylon.TlInfo_SetFileName(self, value)

    def IsFileNameAvailable(self):
        return _pylon.TlInfo_IsFileNameAvailable(self)

    def GetInfoID(self):
        return _pylon.TlInfo_GetInfoID(self)

    def SetInfoID(self, value):
        return _pylon.TlInfo_SetInfoID(self, value)

    def IsInfoIDAvailable(self):
        return _pylon.TlInfo_IsInfoIDAvailable(self)

    def GetModelName(self):
        return _pylon.TlInfo_GetModelName(self)

    def SetModelName(self, value):
        return _pylon.TlInfo_SetModelName(self, value)

    def IsModelNameAvailable(self):
        return _pylon.TlInfo_IsModelNameAvailable(self)

    def GetVersion(self):
        return _pylon.TlInfo_GetVersion(self)

    def SetVersion(self, value):
        return _pylon.TlInfo_SetVersion(self, value)

    def IsVersionAvailable(self):
        return _pylon.TlInfo_IsVersionAvailable(self)

    def __init__(self):
        _pylon.TlInfo_swiginit(self, _pylon.new_TlInfo())
    __swig_destroy__ = _pylon.delete_TlInfo

# Register TlInfo in _pylon:
_pylon.TlInfo_swigregister(TlInfo)
FileNameKey = cvar.FileNameKey
InfoIDKey = cvar.InfoIDKey
VersionKey = cvar.VersionKey

Accessibility_Unknown = _pylon.Accessibility_Unknown
Accessibility_Ok = _pylon.Accessibility_Ok
Accessibility_Opened = _pylon.Accessibility_Opened
Accessibility_OpenedExclusively = _pylon.Accessibility_OpenedExclusively
Accessibility_NotReachable = _pylon.Accessibility_NotReachable
class IDeviceFactory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def EnumerateDevices(self, *args):
        return _pylon.IDeviceFactory_EnumerateDevices(self, *args)

    def CreateFirstDevice(self, *args):
        return _pylon.IDeviceFactory_CreateFirstDevice(self, *args)

    def CreateDevice(self, *args):
        return _pylon.IDeviceFactory_CreateDevice(self, *args)

    def DestroyDevice(self, arg2):
        return _pylon.IDeviceFactory_DestroyDevice(self, arg2)

    def IsDeviceAccessible(self, *args):
        return _pylon.IDeviceFactory_IsDeviceAccessible(self, *args)
    __swig_destroy__ = _pylon.delete_IDeviceFactory

# Register IDeviceFactory in _pylon:
_pylon.IDeviceFactory_swigregister(IDeviceFactory)
class Interface(IDeviceFactory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Open(self):
        return _pylon.Interface_Open(self)

    def Close(self):
        return _pylon.Interface_Close(self)

    def IsOpen(self):
        return _pylon.Interface_IsOpen(self)

    def GetInterfaceInfo(self):
        return _pylon.Interface_GetInterfaceInfo(self)

    def GetNodeMap(self):
        return _pylon.Interface_GetNodeMap(self)
    InterfaceInfo = property(GetInterfaceInfo) 

    class NodeMapContext:
        def __init__(self, iface):
            self.iface = iface

        def __enter__(self):
            self.iface.Open()
            return self.iface.GetNodeMap()

        def __exit__(self, type, value, traceback):
            self.iface.Close()

    NodeMap = property(NodeMapContext)


# Register Interface in _pylon:
_pylon.Interface_swigregister(Interface)
class TransportLayer(IDeviceFactory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def GetTlInfo(self):
        return _pylon.TransportLayer_GetTlInfo(self)

    def CreateDeviceInfo(self):
        return _pylon.TransportLayer_CreateDeviceInfo(self)

    def GetNodeMap(self):
        return _pylon.TransportLayer_GetNodeMap(self)

    def EnumerateInterfaces(self):
        return _pylon.TransportLayer_EnumerateInterfaces(self)

    def CreateInterface(self, interfaceInfo):
        return _pylon.TransportLayer_CreateInterface(self, interfaceInfo)

    def DestroyInterface(self, pInterface):
        return _pylon.TransportLayer_DestroyInterface(self, pInterface)
    TlInfo = property(GetTlInfo) 
    NodeMap = property(GetNodeMap) 

    class InterfaceContext:
        def __init__(self, tl, iface_info):
            self.tl = tl
            self.iface_info = iface_info
            self.iface = None

        def __enter__(self):
            self.iface = self.tl.CreateInterface(self.iface_info)
            return self.iface

        def __exit__(self, type, value, traceback):
            self.tl.DestroyInterface(self.iface)

    def Interface(self, iface_info):
        return self.InterfaceContext(self, iface_info)

    class InterfaceNodeMapContext:
        def __init__(self, tl, iface_info):
            self.tl = tl
            self.iface_info = iface_info
            self.iface = None

        def __enter__(self):
            self.iface = self.tl.CreateInterface(self.iface_info)
            self.iface.Open()
            return self.iface.GetNodeMap()

        def __exit__(self, type, value, traceback):
            self.iface.Close()
            self.tl.DestroyInterface(self.iface)

    def InterfaceNodeMap(self, iface_info):
        return self.InterfaceNodeMapContext(self, iface_info)



# Register TransportLayer in _pylon:
_pylon.TransportLayer_swigregister(TransportLayer)
GigEActionCommandStatus_Ok = _pylon.GigEActionCommandStatus_Ok
GigEActionCommandStatus_NoRefTime = _pylon.GigEActionCommandStatus_NoRefTime
GigEActionCommandStatus_Overflow = _pylon.GigEActionCommandStatus_Overflow
GigEActionCommandStatus_ActionLate = _pylon.GigEActionCommandStatus_ActionLate
class GigETransportLayer(TransportLayer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def EnumerateAllDevices(self, addToList=False):
        return _pylon.GigETransportLayer_EnumerateAllDevices(self, addToList)

    def ForceIp(self, MacAddress, IpAddress, SubnetMask, DefaultGateway):
        return _pylon.GigETransportLayer_ForceIp(self, MacAddress, IpAddress, SubnetMask, DefaultGateway)

    def RestartIpConfiguration(self, MacAddress):
        return _pylon.GigETransportLayer_RestartIpConfiguration(self, MacAddress)

    def RenounceRemoteDevice(self, IpAddress):
        return _pylon.GigETransportLayer_RenounceRemoteDevice(self, IpAddress)

    def BroadcastIpConfiguration(self, MacAddress, EnablePersistentIp, EnableDhcp, IpAddress, SubnetMask, DefaultGateway, UserdefinedName):
        return _pylon.GigETransportLayer_BroadcastIpConfiguration(self, MacAddress, EnablePersistentIp, EnableDhcp, IpAddress, SubnetMask, DefaultGateway, UserdefinedName)

    def AnnounceRemoteDevice(self, IpAddress):
        return _pylon.GigETransportLayer_AnnounceRemoteDevice(self, IpAddress)

    def IssueActionCommandNoWait(self, deviceKey, groupKey, groupMask, broadcastAddress):
        return _pylon.GigETransportLayer_IssueActionCommandNoWait(self, deviceKey, groupKey, groupMask, broadcastAddress)

    def IssueActionCommandWait(self, deviceKey, groupKey, groupMask, broadcastAddress, timeoutMs, pNumResults):
        return _pylon.GigETransportLayer_IssueActionCommandWait(self, deviceKey, groupKey, groupMask, broadcastAddress, timeoutMs, pNumResults)



        # Add a custom class that serves two purposes:
        # - Provide a simpler interface that the original 'IssueActionCommand'.
        # - Provide easier typemapping.

    class _ActionCommand:

        def __init__(
            self,
            gige_tl,
            deviceKey,
            groupKey,
            groupMask,
            broadcastAddress="255.255.255.255"
            ):
            self.gige_tl = gige_tl
            self.deviceKey = deviceKey
            self.groupKey = groupKey
            self.groupMask = groupMask
            self.broadcastAddress = broadcastAddress

        def IssueNoWait(self):
            return self.gige_tl.IssueActionCommandNoWait(
                self.deviceKey,
                self.groupKey,
                self.groupMask,
                self.broadcastAddress
                )

        def IssueWait(self, timeoutMs, expected_results):
            return self.gige_tl.IssueActionCommandWait(
                self.deviceKey,
                self.groupKey,
                self.groupMask,
                self.broadcastAddress,
                timeoutMs,
                expected_results
                )

    def ActionCommand(
        self,
        deviceKey,
        groupKey,
        groupMask,
        broadcastAddress="255.255.255.255"
        ):
        return self._ActionCommand(
            self,
            deviceKey,
            groupKey,
            groupMask,
            broadcastAddress
            )


    def IssueScheduledActionCommandNoWait(self, deviceKey, groupKey, groupMask, actionTimeNs, broadcastAddress):
        return _pylon.GigETransportLayer_IssueScheduledActionCommandNoWait(self, deviceKey, groupKey, groupMask, actionTimeNs, broadcastAddress)

    def IssueScheduledActionCommandWait(self, deviceKey, groupKey, groupMask, actionTimeNs, broadcastAddress, timeoutMs, pNumResults):
        return _pylon.GigETransportLayer_IssueScheduledActionCommandWait(self, deviceKey, groupKey, groupMask, actionTimeNs, broadcastAddress, timeoutMs, pNumResults)



        # Add a custom class that serves two purposes:
        # - Provide a simpler interface that the original 'IssueScheduledActionCommand'.
        # - Provide easier typemapping.

    class _ScheduledActionCommand:

        def __init__(
            self,
            gige_tl,
            deviceKey,
            groupKey,
            groupMask,
            actionTimeNs,
            broadcastAddress="255.255.255.255"
            ):
            self.gige_tl = gige_tl
            self.deviceKey = deviceKey
            self.groupKey = groupKey
            self.groupMask = groupMask
            self._actionTimeNs = actionTimeNs
            self.broadcastAddress = broadcastAddress

    # Provide access to actionTimeNs, so that an object can be reused
    # for different action times.

        @property
        def actionTimeNs(self):
            return self._actionTimeNs

        @actionTimeNs.setter
        def actionTimeNs(self, value):
            self._actionTimeNs = value

        def IssueNoWait(self):
            return self.gige_tl.IssueScheduledActionCommandNoWait(
                self.deviceKey,
                self.groupKey,
                self.groupMask,
                self._actionTimeNs,
                self.broadcastAddress
                )

        def IssueWait(self, timeoutMs, expected_results):
            return self.gige_tl.IssueScheduledActionCommandWait(
                self.deviceKey,
                self.groupKey,
                self.groupMask,
                self._actionTimeNs,
                self.broadcastAddress,
                timeoutMs,
                expected_results
                )

    def ScheduledActionCommand(
        self,
        deviceKey,
        groupKey,
        groupMask,
        actionTimeNs,
        broadcastAddress="255.255.255.255"
        ):
        return self._ScheduledActionCommand(
            self,
            deviceKey,
            groupKey,
            groupMask,
            actionTimeNs,
            broadcastAddress
            )



# Register GigETransportLayer in _pylon:
_pylon.GigETransportLayer_swigregister(GigETransportLayer)
class TlFactory(IDeviceFactory):
    r"""


    the Transport Layer Factory  

    Creates, Destroys and Enumerates transport layers as well as their devices.  

    C++ includes: TlFactory.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def GetInstance():
        r"""


        Retrieve the transport layer factory singleton. Throws an exception when
        Pylon::PylonInitialize() has not been called before.  

        """
        return _pylon.TlFactory_GetInstance()

    def EnumerateTls(self):
        r"""


        Retrieve a list of available transport layers.  

        """
        return _pylon.TlFactory_EnumerateTls(self)

    def CreateTl(self, *args):
        r"""


        Create a transport layer object specified by the transport layer's device class
        identifier.  

        """
        return _pylon.TlFactory_CreateTl(self, *args)

    def ReleaseTl(self, pTl):
        r"""


        Destroys a transport layer object.  

        """
        return _pylon.TlFactory_ReleaseTl(self, pTl)

    def EnumerateDevices(self, *args):
        r"""


        returns a list of available devices that match the filter, see IDeviceFactory
        for more information  

        """
        return _pylon.TlFactory_EnumerateDevices(self, *args)

    def CreateFirstDevice(self, *args):
        r"""


        creates first found device from a device info object, injecting additional
        GenICam XML definition strings  

        """
        return _pylon.TlFactory_CreateFirstDevice(self, *args)

    def CreateDevice(self, *args):
        r"""


        This method is deprecated. Use CreateDevice receiving a CDeviceInfo object
        containing the full name as property. example: IPylonDevice* device =
        TlFactory.CreateDevice( CDeviceInfo().SetFullName( fullname)); creates a device
        by its unique name (i.e. fullname)  

        """
        return _pylon.TlFactory_CreateDevice(self, *args)

    def DestroyDevice(self, arg2):
        r"""


        destroys a device  

        """
        return _pylon.TlFactory_DestroyDevice(self, arg2)

    def IsDeviceAccessible(self, *args):
        r"""


        """
        return _pylon.TlFactory_IsDeviceAccessible(self, *args)

# Register TlFactory in _pylon:
_pylon.TlFactory_swigregister(TlFactory)
class GrabResultData(object):
    r"""


    Makes the data for one grabbed buffer available.  

    C++ includes: GrabResultData.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GrabSucceeded(self):
        r"""


        Returns true if an image has been grabbed successfully and false in the case of
        an error.  

        """
        return _pylon.GrabResultData_GrabSucceeded(self)

    def GetErrorDescription(self):
        r"""


        This method returns a description of the error if GrabSucceeded() returns false
        due to an error.  

        """
        return _pylon.GrabResultData_GetErrorDescription(self)

    def GetErrorCode(self):
        r"""


        This method returns the error code if GrabSucceeded() returns false due to an
        error.  

        """
        return _pylon.GrabResultData_GetErrorCode(self)

    def GetPayloadType(self):
        r"""


        Get the current payload type.  

        """
        return _pylon.GrabResultData_GetPayloadType(self)

    def GetPixelType(self):
        r"""


        Get the current pixel type.  

        """
        return _pylon.GrabResultData_GetPixelType(self)

    def GetWidth(self):
        r"""


        Get the current number of columns.  

        """
        return _pylon.GrabResultData_GetWidth(self)

    def GetHeight(self):
        r"""


        Get the current number of rows expressed as number of pixels.  

        """
        return _pylon.GrabResultData_GetHeight(self)

    def GetOffsetX(self):
        r"""


        Get the current starting column.  

        """
        return _pylon.GrabResultData_GetOffsetX(self)

    def GetOffsetY(self):
        r"""


        Get the current starting row.  

        """
        return _pylon.GrabResultData_GetOffsetY(self)

    def GetPaddingX(self):
        r"""


        Get the number of extra data at the end of each row in bytes.  

        """
        return _pylon.GrabResultData_GetPaddingX(self)

    def GetPaddingY(self):
        r"""


        Get the number of extra data at the end of the image data in bytes.  

        """
        return _pylon.GrabResultData_GetPaddingY(self)

    def GetPayloadSize(self):
        r"""


        Get the current payload size in bytes.  

        """
        return _pylon.GrabResultData_GetPayloadSize(self)

    def GetBufferSize(self):
        return _pylon.GrabResultData_GetBufferSize(self)

    def GetBlockID(self):
        r"""


        Get the block ID of the grabbed frame (camera device specific).  

        par: IEEE 1394 Camera Devices
            The value of Block ID is always UINT64_MAX.  

        par: GigE Camera Devices
            The sequence number starts with 1 and wraps at 65535. The value 0 has a
            special meaning and indicates that this feature is not supported by the
            camera.  

        par: USB Camera Devices
            The sequence number starts with 0 and uses the full 64 Bit range.  

        attention: A block ID with the value UINT64_MAX indicates that the block ID is
            invalid and must not be used.  

        """
        return _pylon.GrabResultData_GetBlockID(self)

    def GetTimeStamp(self):
        r"""


        Get the camera specific tick count (camera device specific).  

        This describes when the image exposure was started. Cameras that do not support
        this feature return zero. If supported, this can be used to determine which
        image AOIs were acquired simultaneously.  

        """
        return _pylon.GrabResultData_GetTimeStamp(self)

    def GetStride(self, strideBytes):
        r"""


        Get the stride in byte.  

        """
        return _pylon.GrabResultData_GetStride(self, strideBytes)

    def GetImageSize(self):
        r"""


        Get the size of the image in byte.  

        """
        return _pylon.GrabResultData_GetImageSize(self)

    def GetCameraContext(self):
        r"""


        Get the context value assigned to the camera object. The context is attached to
        the result when it is retrieved.  

        """
        return _pylon.GrabResultData_GetCameraContext(self)

    def GetID(self):
        r"""


        Get the ID of the grabbed image.  

        Always returns a number larger than 0. The counting starts with 1 and is never
        reset during the lifetime of the Instant Camera object.  

        """
        return _pylon.GrabResultData_GetID(self)

    def GetImageNumber(self):
        r"""


        Get the number of the image. This number is incremented when an image is
        retrieved using CInstantCamera::RetrieveResult().  

        Always returns a number larger than 0. The counting starts with 1 and is reset
        with every call to CInstantCamera::StartGrabbing().  

        """
        return _pylon.GrabResultData_GetImageNumber(self)

    def GetNumberOfSkippedImages(self):
        r"""


        Get the number of skipped images before this image.  

        This value can be larger than 0 if EGrabStrategy_LatestImageOnly grab strategy
        or GrabStrategy_LatestImages grab strategy is used. Always returns a number
        larger than or equal 0. This number does not include the number of images lost
        in case of a buffer underrun in the driver.  

        """
        return _pylon.GrabResultData_GetNumberOfSkippedImages(self)

    def IsChunkDataAvailable(self):
        r"""


        Returns true if chunk data is available.  

        This is the case if the chunk mode is enabled for the camera device. The
        parameter CInstantCamera::ChunkNodeMapsEnable of the used Instant Camera object
        is set to true (default setting). Chunk data node maps are supported by the
        Transport Layer of the camera device.  

        """
        return _pylon.GrabResultData_IsChunkDataAvailable(self)

    def GetChunkDataNodeMap(self):
        r"""


        Get the reference to the chunk data node map connected to the result.  

        An empty node map is returned when the device does not support this feature or
        when chunks are disabled.  

        """
        return _pylon.GrabResultData_GetChunkDataNodeMap(self)

    def HasCRC(self):
        r"""


        Checks if buffer has a CRC attached. This needs not be activated for the device.
        See the PayloadCRC16 chunk.  

        """
        return _pylon.GrabResultData_HasCRC(self)

    def CheckCRC(self):
        r"""


        Checks CRC sum of buffer, returns true if CRC sum is OK.  

        """
        return _pylon.GrabResultData_CheckCRC(self)

    def GetBufferContext(self):
        r"""


        Get the context value assigned to the buffer. The context is set when
        CInstamtCamera is using a custom buffer factory.  

        """
        return _pylon.GrabResultData_GetBufferContext(self)

    def GetDataContainer(self):
        return _pylon.GrabResultData_GetDataContainer(self)

    def GetDataComponentCount(self):
        return _pylon.GrabResultData_GetDataComponentCount(self)

    def GetDataComponent(self, index):
        return _pylon.GrabResultData_GetDataComponent(self, index)

    def GetGrabResultDataImpl(self):
        r"""


        """
        return _pylon.GrabResultData_GetGrabResultDataImpl(self)
    __swig_destroy__ = _pylon.delete_GrabResultData

    def GetBuffer(self):
        r"""


        Get the pointer to the buffer.  

        If the chunk data feature is activated for the device, chunk data is appended to
        the image data. When writing past the image section while performing image
        processing, the chunk data will be corrupted.  

        """
        return _pylon.GrabResultData_GetBuffer(self)

    def GetImageBuffer(self):
        return _pylon.GrabResultData_GetImageBuffer(self)

    def GetMemoryView(self):
        return _pylon.GrabResultData_GetMemoryView(self)

    def GetImageMemoryView(self):
        return _pylon.GrabResultData_GetImageMemoryView(self)

    def _Unpack10or12BitPacked(self):
        return _pylon.GrabResultData__Unpack10or12BitPacked(self)

# Register GrabResultData in _pylon:
_pylon.GrabResultData_swigregister(GrabResultData)

from contextlib import contextmanager
import sys

class GrabResult(object):
    r"""


    A smart pointer holding a reference to grab result data.  

    This class is used for distributing the grab result data of a camera. It
    controls the reuse and lifetime of the referenced buffer. When all smart
    pointers referencing a buffer go out of scope the referenced buffer is reused or
    destroyed. The data and the held buffer are still valid after the camera object
    it originated from has been destroyed.  

    attention: The grabbing will stop with an input queue underrun, when the grab
        results are never released, e.g. when put into a container.  

    The CGrabResultPtr class provides a cast operator that allows passing the grab
    result directly to functions or methods that take an const IImage& as parameter,
    e.g. image saving functions or image format converter methods.  

    attention: The returned reference to IImage is only valid as long the
        CGrabResultPtr object it came from is not destroyed.  

    Instances of CGrabResultPtr referencing the same grab result can be used from
    any thread context.  

    C++ includes: GrabResultPtr.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Creates a copy of a smart pointer.  

        Parameters
        ----------
        * `rhs` :  
            Another smart pointer, source of the result data to reference.  

        The data itself is not copied.  

        post:  

            *   Another reference to the grab result of the source is held if it
                references a grab result.  
            *   No grab result is referenced if the source does not reference a grab
                result.  

        Still valid after error.  

        """
        _pylon.GrabResult_swiginit(self, _pylon.new_GrabResult(*args))
    __swig_destroy__ = _pylon.delete_GrabResult

    def __deref__(self):
        return _pylon.GrabResult___deref__(self)

    def IsValid(self):
        r"""


        Check whether data is referenced.  

        Returns
        -------
        True if data is referenced.  

        Does not throw C++ exceptions.  

        """
        return _pylon.GrabResult_IsValid(self)

    def __nonzero__(self):
        return _pylon.GrabResult___nonzero__(self)
    __bool__ = __nonzero__



    def Release(self):
        r"""


        The currently referenced data is released.  

        post: The currently referenced data is released.  

        Still valid after error.  

        """
        return _pylon.GrabResult_Release(self)

    def IsUnique(self):
        r"""


        Indicates that the held grab result data and buffer is only referenced by this
        grab result.  

        Returns
        -------
        Returns true if the held grab result data and buffer is only referenced by this
        grab result. Returns false if the grab result is invalid.  

        Does not throw C++ exceptions.  

        """
        return _pylon.GrabResult_IsUnique(self)

    @needs_numpy
    def GetImageFormat(self, pt = None):
        if pt is None:
            pt = self.GetPixelType()
        if IsPacked(pt):
            raise ValueError("Packed Formats are not supported with numpy interface")
        if pt in ( PixelType_Mono8, PixelType_BayerGR8, PixelType_BayerRG8, PixelType_BayerGB8, PixelType_BayerBG8, PixelType_Confidence8, PixelType_Coord3D_C8 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "B"
            dtype = _pylon_numpy.uint8
        elif pt in ( PixelType_Mono10, PixelType_BayerGR10, PixelType_BayerRG10, PixelType_BayerGB10, PixelType_BayerBG10 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono12, PixelType_BayerGR12, PixelType_BayerRG12, PixelType_BayerGB12, PixelType_BayerBG12 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono16, PixelType_BayerGR16, PixelType_BayerRG16, PixelType_BayerGB16, PixelType_BayerBG16, PixelType_Confidence16, PixelType_Coord3D_C16 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_RGB8packed, PixelType_BGR8packed ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_YUV422_YUYV_Packed, PixelType_YUV422packed ):
            shape = (self.GetHeight(), self.GetWidth(), 2)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_Coord3D_ABC32f, ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.float32
            format = "f"
        else:
            raise ValueError("Pixel format currently not supported")

        return (shape, dtype, format)

    @needs_numpy
    def GetArray(self, raw = False):

    # Raw case => Simple byte wrapping of buffer
        if raw:
            shape, dtype, format = ( self.GetPayloadSize() ), _pylon_numpy.uint8, "B"
            buf = self.GetBuffer()
            return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

        pt = self.GetPixelType()
        if IsPacked(pt):
            buf, new_pt = self._Unpack10or12BitPacked()
            shape, dtype, format = self.GetImageFormat(new_pt)
        else:
            shape, dtype, format = self.GetImageFormat(pt)
            buf = self.GetImageBuffer()

    # Now we will copy the data into an array:
        return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

    def GetChunkNode( self, nodeName ):
        return self.GetChunkDataNodeMap().GetNode(nodeName)

    def __getattr__(self, attribute):
    # Check "normal" attributes first
        if attribute in self.__dict__ or attribute in ("thisown", "this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)

    # If chunk data is available, maybe "attribute" is a chunk node?
        if self.IsChunkDataAvailable():
            try:
                return self.GetChunkNode(attribute)
            except pypylon.genicam.LogicalErrorException:
                pass

    # Nothing found -> Raise AttributeError
        raise AttributeError("no attribute '%s' in GrabResult" % attribute)

    def __setattr__(self, attribute, val):
    # Check "normal" attributes first
        if attribute in self.__dict__ or attribute in ("thisown", "this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
            return

    # If chunk data is available, maybe "attribute" is a chunk node?
        if self.IsChunkDataAvailable():
            try:
                node = self.GetChunkNode(attribute)
            except pypylon.genicam.LogicalErrorException:
                pass
            else:
                warnings.warn(f"Setting a feature value by direct assignment is deprecated. Use <nodemap>.{node.Node.GetName()}.Value = {val}", DeprecationWarning, stacklevel=2)
                node.SetValue(val)
                return

    # Nothing found -> Raise AttributeError
        raise AttributeError("no attribute '%s' in GrabResult" % attribute)

    def __dir__(self):
        l = dir(type(self))
        l.extend(self.__dict__.keys())
        try:
            nodes = self.GetChunkDataNodeMap().GetNodes()
            chunks = filter(lambda n: "ChunkData" in (f.GetNode().Name for f in n.GetNode().GetParents()), nodes)
            l.extend(x.GetNode().GetName() for x in chunks)
        except:
            pass
        return sorted(set(l))

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.Release()

    @contextmanager
    @needs_numpy
    def GetArrayZeroCopy(self, raw = False):
        '''
        Get a numpy array for the image buffer as zero copy reference to the underlying buffer.
        Note: The context manager variable MUST be released before leaving the scope.
        '''

    # For packed formats, we cannot zero-copy, so use GetArray
        pt = self.GetPixelType()
        if IsPacked(pt):
            yield self.GetArray()
            return

        mv = self.GetImageMemoryView()
        if not raw:
            shape, dtype, format = self.GetImageFormat()
            mv = mv.cast(format, shape)

        ar = _pylon_numpy.asarray(mv)

    # trace external references to array
        initial_refcount = sys.getrefcount(ar)

    # yield the array to the context code
        yield ar

    # detect if more refs than the one from the yield are held
        if sys.getrefcount(ar) > initial_refcount + 1:
            raise RuntimeError("Please remove any references to the array before leaving context manager scope!!!")

    # release the memory view
        mv.release()



    def GrabSucceeded(self):
        r"""


        Returns true if an image has been grabbed successfully and false in the case of
        an error.  

        """
        return _pylon.GrabResult_GrabSucceeded(self)

    def GetErrorDescription(self):
        r"""


        This method returns a description of the error if GrabSucceeded() returns false
        due to an error.  

        """
        return _pylon.GrabResult_GetErrorDescription(self)

    def GetErrorCode(self):
        r"""


        This method returns the error code if GrabSucceeded() returns false due to an
        error.  

        """
        return _pylon.GrabResult_GetErrorCode(self)

    def GetPayloadType(self):
        r"""


        Get the current payload type.  

        """
        return _pylon.GrabResult_GetPayloadType(self)

    def GetPixelType(self):
        r"""


        Get the current pixel type.  

        """
        return _pylon.GrabResult_GetPixelType(self)

    def GetWidth(self):
        r"""


        Get the current number of columns.  

        """
        return _pylon.GrabResult_GetWidth(self)

    def GetHeight(self):
        r"""


        Get the current number of rows expressed as number of pixels.  

        """
        return _pylon.GrabResult_GetHeight(self)

    def GetOffsetX(self):
        r"""


        Get the current starting column.  

        """
        return _pylon.GrabResult_GetOffsetX(self)

    def GetOffsetY(self):
        r"""


        Get the current starting row.  

        """
        return _pylon.GrabResult_GetOffsetY(self)

    def GetPaddingX(self):
        r"""


        Get the number of extra data at the end of each row in bytes.  

        """
        return _pylon.GrabResult_GetPaddingX(self)

    def GetPaddingY(self):
        r"""


        Get the number of extra data at the end of the image data in bytes.  

        """
        return _pylon.GrabResult_GetPaddingY(self)

    def GetPayloadSize(self):
        r"""


        Get the current payload size in bytes.  

        """
        return _pylon.GrabResult_GetPayloadSize(self)

    def GetBufferSize(self):
        return _pylon.GrabResult_GetBufferSize(self)

    def GetBlockID(self):
        r"""


        Get the block ID of the grabbed frame (camera device specific).  

        par: IEEE 1394 Camera Devices
            The value of Block ID is always UINT64_MAX.  

        par: GigE Camera Devices
            The sequence number starts with 1 and wraps at 65535. The value 0 has a
            special meaning and indicates that this feature is not supported by the
            camera.  

        par: USB Camera Devices
            The sequence number starts with 0 and uses the full 64 Bit range.  

        attention: A block ID with the value UINT64_MAX indicates that the block ID is
            invalid and must not be used.  

        """
        return _pylon.GrabResult_GetBlockID(self)

    def GetTimeStamp(self):
        r"""


        Get the camera specific tick count (camera device specific).  

        This describes when the image exposure was started. Cameras that do not support
        this feature return zero. If supported, this can be used to determine which
        image AOIs were acquired simultaneously.  

        """
        return _pylon.GrabResult_GetTimeStamp(self)

    def GetStride(self, strideBytes):
        r"""


        Get the stride in byte.  

        """
        return _pylon.GrabResult_GetStride(self, strideBytes)

    def GetImageSize(self):
        r"""


        Get the size of the image in byte.  

        """
        return _pylon.GrabResult_GetImageSize(self)

    def GetCameraContext(self):
        r"""


        Get the context value assigned to the camera object. The context is attached to
        the result when it is retrieved.  

        """
        return _pylon.GrabResult_GetCameraContext(self)

    def GetID(self):
        r"""


        Get the ID of the grabbed image.  

        Always returns a number larger than 0. The counting starts with 1 and is never
        reset during the lifetime of the Instant Camera object.  

        """
        return _pylon.GrabResult_GetID(self)

    def GetImageNumber(self):
        r"""


        Get the number of the image. This number is incremented when an image is
        retrieved using CInstantCamera::RetrieveResult().  

        Always returns a number larger than 0. The counting starts with 1 and is reset
        with every call to CInstantCamera::StartGrabbing().  

        """
        return _pylon.GrabResult_GetImageNumber(self)

    def GetNumberOfSkippedImages(self):
        r"""


        Get the number of skipped images before this image.  

        This value can be larger than 0 if EGrabStrategy_LatestImageOnly grab strategy
        or GrabStrategy_LatestImages grab strategy is used. Always returns a number
        larger than or equal 0. This number does not include the number of images lost
        in case of a buffer underrun in the driver.  

        """
        return _pylon.GrabResult_GetNumberOfSkippedImages(self)

    def IsChunkDataAvailable(self):
        r"""


        Returns true if chunk data is available.  

        This is the case if the chunk mode is enabled for the camera device. The
        parameter CInstantCamera::ChunkNodeMapsEnable of the used Instant Camera object
        is set to true (default setting). Chunk data node maps are supported by the
        Transport Layer of the camera device.  

        """
        return _pylon.GrabResult_IsChunkDataAvailable(self)

    def GetChunkDataNodeMap(self):
        r"""


        Get the reference to the chunk data node map connected to the result.  

        An empty node map is returned when the device does not support this feature or
        when chunks are disabled.  

        """
        return _pylon.GrabResult_GetChunkDataNodeMap(self)

    def HasCRC(self):
        r"""


        Checks if buffer has a CRC attached. This needs not be activated for the device.
        See the PayloadCRC16 chunk.  

        """
        return _pylon.GrabResult_HasCRC(self)

    def CheckCRC(self):
        r"""


        Checks CRC sum of buffer, returns true if CRC sum is OK.  

        """
        return _pylon.GrabResult_CheckCRC(self)

    def GetBufferContext(self):
        r"""


        Get the context value assigned to the buffer. The context is set when
        CInstamtCamera is using a custom buffer factory.  

        """
        return _pylon.GrabResult_GetBufferContext(self)

    def GetDataContainer(self):
        return _pylon.GrabResult_GetDataContainer(self)

    def GetDataComponentCount(self):
        return _pylon.GrabResult_GetDataComponentCount(self)

    def GetDataComponent(self, index):
        return _pylon.GrabResult_GetDataComponent(self, index)

    def GetGrabResultDataImpl(self):
        r"""


        """
        return _pylon.GrabResult_GetGrabResultDataImpl(self)

    def GetBuffer(self):
        r"""


        Get the pointer to the buffer.  

        If the chunk data feature is activated for the device, chunk data is appended to
        the image data. When writing past the image section while performing image
        processing, the chunk data will be corrupted.  

        """
        return _pylon.GrabResult_GetBuffer(self)

    def GetImageBuffer(self):
        return _pylon.GrabResult_GetImageBuffer(self)

    def GetMemoryView(self):
        return _pylon.GrabResult_GetMemoryView(self)

    def GetImageMemoryView(self):
        return _pylon.GrabResult_GetImageMemoryView(self)

    def _Unpack10or12BitPacked(self):
        return _pylon.GrabResult__Unpack10or12BitPacked(self)

# Register GrabResult in _pylon:
_pylon.GrabResult_swigregister(GrabResult)
waitex_timeout = _pylon.waitex_timeout
waitex_signaled = _pylon.waitex_signaled
waitex_abandoned = _pylon.waitex_abandoned
waitex_alerted = _pylon.waitex_alerted
ready_none = _pylon.ready_none
ready_read = _pylon.ready_read
ready_write = _pylon.ready_write
ready_except = _pylon.ready_except
class WaitObject(object):
    r"""


    A platform independent wait object.  

    Wait objects are used by the Pylon::IStreamGrabber and Pylon::IEventGrabber
    interfaces to provide a platform independent mechanism for allowing an
    application to wait for data buffers to be filled.  

    For the Windows version of pylon, WaitObjects are wrappers for Win32 objects
    that can be used with `WaitForSingleObject()` and `WaitForMultipleObjects()`.  

    For the Linux version of pylon, WaitObjects are implemented based on file
    descriptors. The wait operation is implemented using the `poll()` function.  

    Although the class provides a default constructor, the default constructor
    doesn't create a "usable" wait objects wrapping a handle resp. file
    descriptor. Valid instances of Pylon::WaitObject cannot be created by the
    application, instead the pylon libraries return fully created wait objects. The
    Pylon::WaitObjectEx class can be used to create wait objects that can be
    controlled by the application.  

    The Pylon::WaitObject class provides access to the wrapped handle resp. file
    descriptor. This allows to use to allow use pylon wait objects as input for
    "native" APIs like `WaitForMultipleObjects()` (Windows), and `poll()` (Linux).  

    Multiple Pylon::WaitObjects can be put in the Pylon::WaitObjects container class
    allowing to wait "simultaneously" for multiple events.  

    C++ includes: WaitObject.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_WaitObject

    @staticmethod
    def Sleep(ms):
        r"""


        Suspend calling thread for specified time.  

        Parameters
        ----------
        * `ms` :  
            wait time in ms  

        """
        return _pylon.WaitObject_Sleep(ms)

    def IsValid(self):
        r"""


        Checks if the wait object is valid.  

        Don't call the Wait methods() for an invalid wait object. Wait objects returned
        by the pylon libraries are valid.  

        Returns
        -------
        true if the object contains a valid handle/file descriptor  

        """
        return _pylon.WaitObject_IsValid(self)

    def Wait(self, timeout):
        r"""


        Wait for the object to be signaled.  

        Parameters
        ----------
        * `timeout` :  
            timeout in ms  

        Returns
        -------
        false when the timeout has been expired, true when the waiting was successful
        before the timeout has been expired.  

        """
        return _pylon.WaitObject_Wait(self, timeout)

    def WaitEx(self, timeout, bAlertable):
        r"""


        Wait for the object to be signaled (interruptible).  

        Parameters
        ----------
        * `timeout` :  
            timeout in ms  
        * `bAlertable` :  
            When the bAlertable parameter is set to true, the function waits until
            either the timeout elapses, the object enters the signaled state, or the
            wait operation has been interrupted. For Windows, the wait operation is
            interrupted by queued APCs or I/O completion routines. For Linux, the wait
            operation can be interrupted by signals.  

        Returns
        -------
        The returned Pylon::EWaitExResult value indicates the result of the wait
        operation.  

        """
        return _pylon.WaitObject_WaitEx(self, timeout, bAlertable)

    def __init__(self, *args):
        r"""


        Constructor taking existing handle (duplicate=false -> take ownership like
        std:auto_ptr).  

        This method allows to wrap an existing windows handle that can be used with the
        `WaitForSingleObject()` and `WaitForMultipleObjects` methods.  

        """
        _pylon.WaitObject_swiginit(self, _pylon.new_WaitObject(*args))

    def Destroy(self):
        return _pylon.WaitObject_Destroy(self)

    def GetFd(self):
        return _pylon.WaitObject_GetFd(self)

    def GetReadyMask(self):
        return _pylon.WaitObject_GetReadyMask(self)

    def GetWaitObject(self):
        return _pylon.WaitObject_GetWaitObject(self)

# Register WaitObject in _pylon:
_pylon.WaitObject_swigregister(WaitObject)
waitForever = cvar.waitForever

class WaitObjects(object):
    r"""


    A set of wait objects.  

    C++ includes: WaitObjects.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_WaitObjects

    def __init__(self, *args):
        r"""


        copy constructor  

        """
        _pylon.WaitObjects_swiginit(self, _pylon.new_WaitObjects(*args))

    def Add(self, o):
        r"""


        Add an object to wait on and return the index of the added object.  

        Calling Add from another thread during wait operations will cause undefined
        behaviour.  

        """
        return _pylon.WaitObjects_Add(self, o)

    def RemoveAll(self):
        r"""


        Removes all added wait objects.  

        Calling RemoveAll from another thread during wait operations will cause
        undefined behaviour.  

        """
        return _pylon.WaitObjects_RemoveAll(self)

    def WaitForAll(self, timeout):
        r"""


        Wait for all objects to get signaled.  

        Parameters
        ----------
        * `timeout` :  
            maximum wait period in milliseconds  

        Returns
        -------
        true if all objects were signaled  

        """
        return _pylon.WaitObjects_WaitForAll(self, timeout)

    def WaitForAny(self, timeout, pIndex=None):
        r"""


        Wait for any one object to get signaled.  

        Parameters
        ----------
        * `timeout` :  
            maximum wait period in milliseconds  
        * `*pIndex` :  
            (optional) pointer to buffer taking the index of the signaled object  

        Returns
        -------
        true if any object was signaled.  

        """
        return _pylon.WaitObjects_WaitForAny(self, timeout, pIndex)

    def WaitForAllEx(self, timeout, bAlertable):
        r"""


        Wait for all objects to get signaled.  

        Parameters
        ----------
        * `bAlertable` :  
            If true, the wait operation can be interrupted (Windows: APC; UNIX: signal)  
        * `timeout` :  
            maximum wait period in milliseconds  

        """
        return _pylon.WaitObjects_WaitForAllEx(self, timeout, bAlertable)

    def WaitForAnyEx(self, timeout, bAlertable, pIndex=None):
        r"""


        Wait for any one object to get signaled.  

        Parameters
        ----------
        * `timeout` :  
            maximum wait period in milliseconds  
        * `bAlertable` :  
            If true, the wait operation can be interrupted (Windows: APC; UNIX: signal)  
        * `*pIndex` :  
            (optional) pointer to buffer taking the index of the signaled object  

        """
        return _pylon.WaitObjects_WaitForAnyEx(self, timeout, bAlertable, pIndex)

# Register WaitObjects in _pylon:
_pylon.WaitObjects_swigregister(WaitObjects)
class CInstantCameraParams_Params_v7_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    AcquisitionStartStopExecutionEnable = property(_pylon.CInstantCameraParams_Params_v7_3_1_AcquisitionStartStopExecutionEnable_get, _pylon.CInstantCameraParams_Params_v7_3_1_AcquisitionStartStopExecutionEnable_set)
    ChunkNodeMapsEnable = property(_pylon.CInstantCameraParams_Params_v7_3_1_ChunkNodeMapsEnable_get, _pylon.CInstantCameraParams_Params_v7_3_1_ChunkNodeMapsEnable_set)
    ClearBufferModeEnable = property(_pylon.CInstantCameraParams_Params_v7_3_1_ClearBufferModeEnable_get, _pylon.CInstantCameraParams_Params_v7_3_1_ClearBufferModeEnable_set)
    GrabCameraEvents = property(_pylon.CInstantCameraParams_Params_v7_3_1_GrabCameraEvents_get, _pylon.CInstantCameraParams_Params_v7_3_1_GrabCameraEvents_set)
    GrabLoopThreadPriority = property(_pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadPriority_get, _pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadPriority_set)
    GrabLoopThreadPriorityOverride = property(_pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadPriorityOverride_get, _pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadPriorityOverride_set)
    GrabLoopThreadTimeout = property(_pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadTimeout_get, _pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadTimeout_set)
    GrabLoopThreadUseTimeout = property(_pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadUseTimeout_get, _pylon.CInstantCameraParams_Params_v7_3_1_GrabLoopThreadUseTimeout_set)
    InternalGrabEngineThreadPriority = property(_pylon.CInstantCameraParams_Params_v7_3_1_InternalGrabEngineThreadPriority_get, _pylon.CInstantCameraParams_Params_v7_3_1_InternalGrabEngineThreadPriority_set)
    InternalGrabEngineThreadPriorityOverride = property(_pylon.CInstantCameraParams_Params_v7_3_1_InternalGrabEngineThreadPriorityOverride_get, _pylon.CInstantCameraParams_Params_v7_3_1_InternalGrabEngineThreadPriorityOverride_set)
    MaxNumBuffer = property(_pylon.CInstantCameraParams_Params_v7_3_1_MaxNumBuffer_get, _pylon.CInstantCameraParams_Params_v7_3_1_MaxNumBuffer_set)
    MaxNumGrabResults = property(_pylon.CInstantCameraParams_Params_v7_3_1_MaxNumGrabResults_get, _pylon.CInstantCameraParams_Params_v7_3_1_MaxNumGrabResults_set)
    MaxNumQueuedBuffer = property(_pylon.CInstantCameraParams_Params_v7_3_1_MaxNumQueuedBuffer_get, _pylon.CInstantCameraParams_Params_v7_3_1_MaxNumQueuedBuffer_set)
    MigrationModeActive = property(_pylon.CInstantCameraParams_Params_v7_3_1_MigrationModeActive_get, _pylon.CInstantCameraParams_Params_v7_3_1_MigrationModeActive_set)
    MonitorModeActive = property(_pylon.CInstantCameraParams_Params_v7_3_1_MonitorModeActive_get, _pylon.CInstantCameraParams_Params_v7_3_1_MonitorModeActive_set)
    NumEmptyBuffers = property(_pylon.CInstantCameraParams_Params_v7_3_1_NumEmptyBuffers_get, _pylon.CInstantCameraParams_Params_v7_3_1_NumEmptyBuffers_set)
    NumQueuedBuffers = property(_pylon.CInstantCameraParams_Params_v7_3_1_NumQueuedBuffers_get, _pylon.CInstantCameraParams_Params_v7_3_1_NumQueuedBuffers_set)
    NumReadyBuffers = property(_pylon.CInstantCameraParams_Params_v7_3_1_NumReadyBuffers_get, _pylon.CInstantCameraParams_Params_v7_3_1_NumReadyBuffers_set)
    OutputQueueSize = property(_pylon.CInstantCameraParams_Params_v7_3_1_OutputQueueSize_get, _pylon.CInstantCameraParams_Params_v7_3_1_OutputQueueSize_set)
    StaticChunkNodeMapPoolSize = property(_pylon.CInstantCameraParams_Params_v7_3_1_StaticChunkNodeMapPoolSize_get, _pylon.CInstantCameraParams_Params_v7_3_1_StaticChunkNodeMapPoolSize_set)
    UseExtendedIdIfAvailable = property(_pylon.CInstantCameraParams_Params_v7_3_1_UseExtendedIdIfAvailable_get, _pylon.CInstantCameraParams_Params_v7_3_1_UseExtendedIdIfAvailable_set)

# Register CInstantCameraParams_Params_v7_3_1 in _pylon:
_pylon.CInstantCameraParams_Params_v7_3_1_swigregister(CInstantCameraParams_Params_v7_3_1)
class InstantCameraParams_Params(CInstantCameraParams_Params_v7_3_1):
    r"""


    Interface to instant camera parameters.  

    C++ includes: _InstantCameraParams.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _GetBaseType_MaxNumBuffer(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_MaxNumBuffer(self)

    def _Get_MaxNumBuffer(self):
       return self._GetBaseType_MaxNumBuffer()
    def _Set_MaxNumBuffer(self, value):
       self._GetBaseType_MaxNumBuffer().SetValue(value)
    MaxNumBuffer = property(_Get_MaxNumBuffer, _Set_MaxNumBuffer )


    def _GetBaseType_MaxNumQueuedBuffer(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_MaxNumQueuedBuffer(self)

    def _Get_MaxNumQueuedBuffer(self):
       return self._GetBaseType_MaxNumQueuedBuffer()
    def _Set_MaxNumQueuedBuffer(self, value):
       self._GetBaseType_MaxNumQueuedBuffer().SetValue(value)
    MaxNumQueuedBuffer = property(_Get_MaxNumQueuedBuffer, _Set_MaxNumQueuedBuffer )


    def _GetBaseType_MaxNumGrabResults(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_MaxNumGrabResults(self)

    def _Get_MaxNumGrabResults(self):
       return self._GetBaseType_MaxNumGrabResults()
    def _Set_MaxNumGrabResults(self, value):
       self._GetBaseType_MaxNumGrabResults().SetValue(value)
    MaxNumGrabResults = property(_Get_MaxNumGrabResults, _Set_MaxNumGrabResults )


    def _GetBaseType_ChunkNodeMapsEnable(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_ChunkNodeMapsEnable(self)

    def _Get_ChunkNodeMapsEnable(self):
       return self._GetBaseType_ChunkNodeMapsEnable()
    def _Set_ChunkNodeMapsEnable(self, value):
       self._GetBaseType_ChunkNodeMapsEnable().SetValue(value)
    ChunkNodeMapsEnable = property(_Get_ChunkNodeMapsEnable, _Set_ChunkNodeMapsEnable )


    def _GetBaseType_StaticChunkNodeMapPoolSize(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_StaticChunkNodeMapPoolSize(self)

    def _Get_StaticChunkNodeMapPoolSize(self):
       return self._GetBaseType_StaticChunkNodeMapPoolSize()
    def _Set_StaticChunkNodeMapPoolSize(self, value):
       self._GetBaseType_StaticChunkNodeMapPoolSize().SetValue(value)
    StaticChunkNodeMapPoolSize = property(_Get_StaticChunkNodeMapPoolSize, _Set_StaticChunkNodeMapPoolSize )


    def _GetBaseType_GrabCameraEvents(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_GrabCameraEvents(self)

    def _Get_GrabCameraEvents(self):
       return self._GetBaseType_GrabCameraEvents()
    def _Set_GrabCameraEvents(self, value):
       self._GetBaseType_GrabCameraEvents().SetValue(value)
    GrabCameraEvents = property(_Get_GrabCameraEvents, _Set_GrabCameraEvents )


    def _GetBaseType_MonitorModeActive(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_MonitorModeActive(self)

    def _Get_MonitorModeActive(self):
       return self._GetBaseType_MonitorModeActive()
    def _Set_MonitorModeActive(self, value):
       self._GetBaseType_MonitorModeActive().SetValue(value)
    MonitorModeActive = property(_Get_MonitorModeActive, _Set_MonitorModeActive )


    def _GetBaseType_GrabLoopThreadUseTimeout(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_GrabLoopThreadUseTimeout(self)

    def _Get_GrabLoopThreadUseTimeout(self):
       return self._GetBaseType_GrabLoopThreadUseTimeout()
    def _Set_GrabLoopThreadUseTimeout(self, value):
       self._GetBaseType_GrabLoopThreadUseTimeout().SetValue(value)
    GrabLoopThreadUseTimeout = property(_Get_GrabLoopThreadUseTimeout, _Set_GrabLoopThreadUseTimeout )


    def _GetBaseType_GrabLoopThreadTimeout(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_GrabLoopThreadTimeout(self)

    def _Get_GrabLoopThreadTimeout(self):
       return self._GetBaseType_GrabLoopThreadTimeout()
    def _Set_GrabLoopThreadTimeout(self, value):
       self._GetBaseType_GrabLoopThreadTimeout().SetValue(value)
    GrabLoopThreadTimeout = property(_Get_GrabLoopThreadTimeout, _Set_GrabLoopThreadTimeout )


    def _GetBaseType_NumQueuedBuffers(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_NumQueuedBuffers(self)

    def _Get_NumQueuedBuffers(self):
       return self._GetBaseType_NumQueuedBuffers()
    def _Set_NumQueuedBuffers(self, value):
       self._GetBaseType_NumQueuedBuffers().SetValue(value)
    NumQueuedBuffers = property(_Get_NumQueuedBuffers, _Set_NumQueuedBuffers )


    def _GetBaseType_NumReadyBuffers(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_NumReadyBuffers(self)

    def _Get_NumReadyBuffers(self):
       return self._GetBaseType_NumReadyBuffers()
    def _Set_NumReadyBuffers(self, value):
       self._GetBaseType_NumReadyBuffers().SetValue(value)
    NumReadyBuffers = property(_Get_NumReadyBuffers, _Set_NumReadyBuffers )


    def _GetBaseType_NumEmptyBuffers(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_NumEmptyBuffers(self)

    def _Get_NumEmptyBuffers(self):
       return self._GetBaseType_NumEmptyBuffers()
    def _Set_NumEmptyBuffers(self, value):
       self._GetBaseType_NumEmptyBuffers().SetValue(value)
    NumEmptyBuffers = property(_Get_NumEmptyBuffers, _Set_NumEmptyBuffers )


    def _GetBaseType_OutputQueueSize(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_OutputQueueSize(self)

    def _Get_OutputQueueSize(self):
       return self._GetBaseType_OutputQueueSize()
    def _Set_OutputQueueSize(self, value):
       self._GetBaseType_OutputQueueSize().SetValue(value)
    OutputQueueSize = property(_Get_OutputQueueSize, _Set_OutputQueueSize )


    def _GetBaseType_InternalGrabEngineThreadPriorityOverride(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_InternalGrabEngineThreadPriorityOverride(self)

    def _Get_InternalGrabEngineThreadPriorityOverride(self):
       return self._GetBaseType_InternalGrabEngineThreadPriorityOverride()
    def _Set_InternalGrabEngineThreadPriorityOverride(self, value):
       self._GetBaseType_InternalGrabEngineThreadPriorityOverride().SetValue(value)
    InternalGrabEngineThreadPriorityOverride = property(_Get_InternalGrabEngineThreadPriorityOverride, _Set_InternalGrabEngineThreadPriorityOverride )


    def _GetBaseType_InternalGrabEngineThreadPriority(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_InternalGrabEngineThreadPriority(self)

    def _Get_InternalGrabEngineThreadPriority(self):
       return self._GetBaseType_InternalGrabEngineThreadPriority()
    def _Set_InternalGrabEngineThreadPriority(self, value):
       self._GetBaseType_InternalGrabEngineThreadPriority().SetValue(value)
    InternalGrabEngineThreadPriority = property(_Get_InternalGrabEngineThreadPriority, _Set_InternalGrabEngineThreadPriority )


    def _GetBaseType_GrabLoopThreadPriorityOverride(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_GrabLoopThreadPriorityOverride(self)

    def _Get_GrabLoopThreadPriorityOverride(self):
       return self._GetBaseType_GrabLoopThreadPriorityOverride()
    def _Set_GrabLoopThreadPriorityOverride(self, value):
       self._GetBaseType_GrabLoopThreadPriorityOverride().SetValue(value)
    GrabLoopThreadPriorityOverride = property(_Get_GrabLoopThreadPriorityOverride, _Set_GrabLoopThreadPriorityOverride )


    def _GetBaseType_GrabLoopThreadPriority(self):
        return _pylon.InstantCameraParams_Params__GetBaseType_GrabLoopThreadPriority(self)

    def _Get_GrabLoopThreadPriority(self):
       return self._GetBaseType_GrabLoopThreadPriority()
    def _Set_GrabLoopThreadPriority(self, value):
       self._GetBaseType_GrabLoopThreadPriority().SetValue(value)
    GrabLoopThreadPriority = property(_Get_GrabLoopThreadPriority, _Set_GrabLoopThreadPriority )


# Register InstantCameraParams_Params in _pylon:
_pylon.InstantCameraParams_Params_swigregister(InstantCameraParams_Params)
Cleanup_None = _pylon.Cleanup_None
Cleanup_Delete = _pylon.Cleanup_Delete
RegistrationMode_Append = _pylon.RegistrationMode_Append
RegistrationMode_ReplaceAll = _pylon.RegistrationMode_ReplaceAll
TimeoutHandling_Return = _pylon.TimeoutHandling_Return
TimeoutHandling_ThrowException = _pylon.TimeoutHandling_ThrowException
GrabStrategy_OneByOne = _pylon.GrabStrategy_OneByOne
GrabStrategy_LatestImageOnly = _pylon.GrabStrategy_LatestImageOnly
GrabStrategy_LatestImages = _pylon.GrabStrategy_LatestImages
GrabStrategy_UpcomingImage = _pylon.GrabStrategy_UpcomingImage
GrabLoop_ProvidedByInstantCamera = _pylon.GrabLoop_ProvidedByInstantCamera
GrabLoop_ProvidedByUser = _pylon.GrabLoop_ProvidedByUser
CameraEventAvailability_Mandatory = _pylon.CameraEventAvailability_Mandatory
CameraEventAvailability_Optional = _pylon.CameraEventAvailability_Optional
class InstantCamera(InstantCameraParams_Params):
    r"""


    Provides convenient access to a camera device.  

    *   Establishes a single access point for accessing camera functionality.  
    *   The class can be used off the shelf without any parameters. The camera uses
        a default configuration for the camera device. This can be overridden.  
    *   Handles Pylon device lifetime. This can be overridden.  
    *   Handles opening and closing of a Pylon device automatically.  
    *   Handles chunk data parsing automatically returning the chunk data in the
        grab result.  
    *   Handles event grabbing automatically providing a convenient interface for
        event callbacks. This can be overridden.  
    *   Handles physical camera device removal.  
    *   Handles the creation, reuse, and destruction of buffers.  
    *   The grabbing can be done in the context of the caller or by using an
        additional grab loop thread.  
    *   The Instant Camera class is extensible using derivation or by registering
        event handler objects.  

    C++ includes: InstantCamera.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Creates an Instant Camera object and calls Attach().  

        See Attach() for more information.  

        Parameters
        ----------
        * `pDevice` :  
            The Pylon device to attach.  
        * `cleanupProcedure` :  
            If cleanupProcedure equals Cleanup_Delete, the Pylon device is destroyed
            when the Instant Camera object is destroyed.  

        May throw an exception if the passed Pylon device is open. Does not throw C++
        exceptions if the passed Pylon device is closed or NULL.  

        """
        _pylon.InstantCamera_swiginit(self, _pylon.new_InstantCamera(*args))
    __swig_destroy__ = _pylon.delete_InstantCamera

    def Attach(self, *args):
        r"""


        Attaches a Pylon device to the Instant Camera.  

        Parameters
        ----------
        * `pDevice` :  
            The Pylon device to attach.  
        * `cleanupProcedure` :  
            If cleanupProcedure equals Cleanup_Delete, the Pylon device is destroyed
            when the Instant Camera object is destroyed.  

        *   If a Pylon device is currently attached, it is destroyed (DestroyDevice())
            or removed (DetachDevice()) depending on the previously set cleanup
            procedure value.  
        *   If the pDevice parameter is NULL, nothing more is done.  
        *   The OnAttach configuration event is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  
        *   The new Pylon device is attached.  
        *   If the passed Pylon device is open, callbacks for camera events are
            registered at the camera node map. (This may fail)  
        *   If the passed Pylon device is open, a device removal call back is
            registered. (This may fail)  
        *   If the passed Pylon device is open, access modifiers (see
            IPylonDevice::Open()) are overtaken as camera parameters.  
        *   The OnAttached configuration event is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  

        post:  

            *   If the passed pointer to the Pylon device is NULL, the Instant Camera
                object is in the "no device attached" state.  
            *   If the passed pointer to the Pylon device is not NULL, the passed Pylon
                device is attached.  
            *   If the set cleanup procedure equals Cleanup_Delete, the Pylon device is
                destroyed when the Instant Camera object is destroyed or a new device is
                attached.  
            *   If the passed Pylon device is open and the registration of callbacks
                fails, the Instant Camera object is in the "no device attached" state.  
            *   The opened-by-user flag is set, preventing closing of the Pylon device
                on StopGrabbing() when the attached Pylon device is already open.  

        May throw an exception if the passed Pylon device is open. Does not throw C++
        exceptions if the passed Pylon device is closed or NULL.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_Attach(self, *args)

    def IsPylonDeviceAttached(self):
        r"""


        Returns the Pylon device attached state of the Instant Camera object.  

        Returns
        -------
        True if a Pylon device is attached.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsPylonDeviceAttached(self)

    def IsCameraDeviceRemoved(self):
        r"""


        Returns the connection state of the camera device.  

        The device removal is only detected while the Instant Camera and therefore the
        attached Pylon device are open.  

        The attached Pylon device is not operable anymore if the camera device has been
        removed from the PC. After it is made sure that no access to the Pylon device or
        any of its node maps is made anymore the Pylon device should be destroyed using
        InstantCamera::DeviceDestroy(). The access to the Pylon device can be protected
        using the lock provided by GetLock(), e.g. when accessing parameters.  

        Returns
        -------
        True if the camera device removal from the PC has been detected.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsCameraDeviceRemoved(self)

    def HasOwnership(self):
        r"""


        Returns the ownership of the attached Pylon device.  

        Returns
        -------
        True if a Pylon device is attached and the Instant Camera object has been given
        the ownership by passing the cleanup procedure Cleanup_Delete when calling
        Attach().  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_HasOwnership(self)

    def DestroyDevice(self):
        r"""


        Destroys the attached Pylon device.  

        attention: The node maps, e.g. the camera node map, of the attached Pylon device
            must not be accessed anymore while destroying the Pylon device.  

        *   If no Pylon device is attached, nothing is done.  
        *   If the Pylon device is open, it is closed by calling Close().  
        *   The configuration event OnDestroy is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  
        *   The Pylon device is destroyed even if the cleanup procedure Cleanup_None has
            been passed when calling Attach() before.  
        *   The configuration event OnDestroyed is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  

        post: No Pylon device is attached.  

        Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_DestroyDevice(self)

    def DetachDevice(self):
        r"""


        Detaches an attached Pylon device.  

        *   If no Pylon device is attached, nothing is done.  
        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   The configuration event OnDetach is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  
        *   The Pylon device is detached.  
        *   The configuration event OnDetached is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  

        Returns
        -------
        The attached Pylon device or NULL if nothing has been attached before.  

        post:  

            *   No Pylon device is attached.  
            *   The ownership of the Pylon device goes to the caller who is responsible
                for destroying the Pylon device.  

        Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_DetachDevice(self)

    def Open(self):
        r"""


        Opens the attached Pylon device.  

        *   Opened by user flag is set, preventing closing of the device on
            StopGrabbing().  
        *   If the Pylon device is already open, nothing more is done.  
        *   The OnOpen configuration event is fired. The notification of event handlers
            stops when an event call triggers an exception.  
        *   The Pylon device is opened.  
        *   A device removal call back is registered at the Pylon device.  
        *   Callbacks for camera events are registered at the camera node map.  
        *   The OnOpened configuration event is fired if the Pylon device has been
            opened successfully. The notification of event handlers stops when an event
            call triggers an exception.  

        pre: A Pylon device is attached.  

        post:  

            *   The Pylon device is open.  
            *   Opened by user flag is set, preventing closing of the Pylon device on
                StopGrabbing().  

        The Instant Camera object is still valid after error. The Pylon device open may
        throw. Configuration event calls may throw. Callback registrations may throw.
        The Pylon device is closed with Close() if the OnOpened event call triggers an
        exception.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_Open(self)

    def IsOpen(self):
        r"""


        Returns the open state of the Pylon device.  Does not throw C++ exceptions.  

        Returns
        -------
        Returns true if a Pylon device is attached and it is open.  This method is
        synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsOpen(self)

    def Close(self):
        r"""


        Closes the attached Pylon device.  

        *   If no Pylon device is attached, nothing is done.  
        *   If the Pylon device is already closed, nothing is done.  
        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   The configuration event OnClose is fired. Possible C++ exceptions from event
            calls are caught and ignored. All event handlers are notified.  
        *   The Pylon device is closed.  
        *   The configuration event OnClosed is fired if the Pylon device has been
            closed successfully. Possible C++ exceptions from event calls are caught and
            ignored. All event handlers are notified.  

        post: The Pylon device is closed.  

        Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_Close(self)

    def StartGrabbing(self, *args):
        r"""


        Starts the grabbing for a maximum number of images.  

        Extends the StartGrabbing(EStrategy, EGrabLoop) by a number of images to grab.
        If the passed count of images has been reached, StopGrabbing is called
        automatically. The images are counted according to the grab strategy. Skipped
        images are not taken into account.  

        The amount of allocated buffers is reduced to maxImages when grabbing fewer
        images than according to the value of the `MaxNumBuffer`  parameter and the grab
        strategy is GrabStrategy_OneByOne.  

        Parameters
        ----------
        * `maxImages` :  
            The count of images to grab. This value must be larger than zero.  
        * `strategy` :  
            The grab strategy. See Pylon::InstantCamera::EStrategy for more information.  
        * `grabLoopType` :  
            If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab
            loop thread is used to run the grab loop.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_StartGrabbing(self, *args)

    def StartGrabbingMax(self, *args):
        r"""


        Starts the grabbing for a maximum number of images.  

        Extends the StartGrabbing(EStrategy, EGrabLoop) by a number of images to grab.
        If the passed count of images has been reached, StopGrabbing is called
        automatically. The images are counted according to the grab strategy. Skipped
        images are not taken into account.  

        The amount of allocated buffers is reduced to maxImages when grabbing fewer
        images than according to the value of the `MaxNumBuffer`  parameter and the grab
        strategy is GrabStrategy_OneByOne.  

        Parameters
        ----------
        * `maxImages` :  
            The count of images to grab. This value must be larger than zero.  
        * `strategy` :  
            The grab strategy. See Pylon::InstantCamera::EStrategy for more information.  
        * `grabLoopType` :  
            If grabLoopType equals GrabLoop_ProvidedByInstantCamera, an additional grab
            loop thread is used to run the grab loop.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_StartGrabbingMax(self, *args)

    def RetrieveResult(self, *args):
        r"""


        Retrieves a grab result according to the strategy, waits if it is not yet
        available.  

        *   The content of the passed grab result is released.  
        *   If no Pylon device is attached or the grabbing is not started, the method
            returns immediately "false".  
        *   Wait for a grab result if it is not yet available. The access to the camera
            is not locked during waiting. Camera events are handled.  
        *   Only if camera events are used: Incoming camera events are handled.  
        *   One grab result is retrieved per call according to the strategy applied.  
        *   Only if chunk mode is used: The chunk data parsing is performed. The grab
            result data is updated using chunk data.  
        *   The image event OnImagesSkipped is fired if grab results have been skipped
            according to the strategy. The notification of event handlers stops when an
            event call triggers an exception.  
        *   The image event OnImageGrabbed is fired if a grab result becomes available.
            The notification of event handlers stops when an event call triggers an
            exception.  
        *   Stops the grabbing by calling StopGrabbing() if the maximum number of images
            has been grabbed.  

        It needs to be checked whether the grab represented by the grab result has been
        successful, see CGrabResultData::GrabSucceeded().  

        Parameters
        ----------
        * `timeoutMs` :  
            A timeout value in ms for waiting for a grab result, or the INFINITE value.  
        * `grabResult` :  
            Receives the grab result.  
        * `timeoutHandling` :  
            If timeoutHandling equals TimeoutHandling_ThrowException, a timeout
            exception is thrown on timeout.  

        Returns
        -------
        True if the call successfully retrieved a grab result, false otherwise.  

        pre:  

            *   There is no other thread waiting for a result. This will be the case
                when the Instant Camera grab loop thread is used.  

        post:  

            *   If a grab result has been retrieved, one image is removed from the
                output queue and is returned in the grabResult parameter.  
            *   If no grab result has been retrieved, an empty grab result is returned
                in the grabResult parameter.  
            *   If the maximum number of images has been grabbed, the grabbing is
                stopped.  
            *   If camera event handling is enabled and camera events were received, at
                least one or more camera event messages have been processed.  

        The Instant Camera object is still valid after error. The grabbing is stopped if
        an exception is thrown.  

        This method is synchronized using the lock provided by GetLock() while not
        waiting.  

        """
        return _pylon.InstantCamera_RetrieveResult(self, *args)

    def StopGrabbing(self):
        r"""


        Stops the grabbing of images.  

        *   Nothing is done if the Instant Camera is not currently grabbing.  
        *   The configuration event OnGrabStop is fired. Possible C++ exceptions from
            event calls are caught and ignored. All event handlers are notified.  
        *   The grabbing is stopped.  
        *   All buffer queues of the Instant Camera are cleared.  
        *   The OnGrabStopped configuration event is fired if the grab has been stopped
            successfully. Possible C++ exceptions from event calls are caught and
            ignored. All event handlers are notified.  
        *   If the Instant Camera has been opened by StartGrabbing, it is closed by
            calling Close().  
        *   Grab-specific parameters of the camera object are unlocked, e.g.
            MaxNumBuffers.  

        post:  

            *   The grabbing is stopped.  
            *   If the Pylon device has been opened by StartGrabbing and no other camera
                object service requires it to be open, it is closed.  
            *   Grab specific parameters of the camera object are unlocked, e.g.
                MaxNumBuffers.  

        Does not throw C++ exceptions. Possible C++ exceptions are caught and ignored.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_StopGrabbing(self)

    def IsGrabbing(self):
        r"""


        Returns state of grabbing.  

        The camera object is grabbing after a successful call to StartGrabbing() until
        StopGrabbing() is called.  

        Returns
        -------
        Returns true if still grabbing.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsGrabbing(self)

    def GrabOne(self, *args):
        r"""


        Grabs one image.  

        The following code shows a simplified version of what is done (happy path):  


        GrabOne() can be used to together with the CAcquireSingleFrameConfiguration.  

        note: Using GrabOne is more efficient if the Pylon device is already open,
            otherwise the Pylon device is opened and closed for each call.  

            Grabbing single images using Software Trigger
            (CSoftwareTriggerConfiguration) is recommended if you want to maximize frame
            rate. This is because the overhead per grabbed image is reduced compared to
            Single Frame Acquisition. The grabbing can be started using StartGrabbing().
            Images are grabbed using the WaitForFrameTriggerReady(),
            ExecuteSoftwareTrigger() and RetrieveResult() methods instead of using
            GrabOne. The grab can be stopped using StopGrabbing() when done.  

        Parameters
        ----------
        * `timeoutMs` :  
            A timeout value in ms for waiting for a grab result, or the INFINITE value.  
        * `grabResult` :  
            Receives the grab result.  
        * `timeoutHandling` :  
            If timeoutHandling equals TimeoutHandling_ThrowException, a timeout
            exception is thrown on timeout.  

        Returns
        -------
        Returns true if the call successfully retrieved a grab result and the grab
        succeeded (CGrabResultData::GrabSucceeded()).  

        pre: Must meet the preconditions of start grabbing.  

        post: Meets the postconditions of stop grabbing.  

        The Instant Camera object is still valid after error. See StartGrabbing(),
        RetrieveResult(), and StopGrabbing() . In the case of exceptions after
        StartGrabbing() the grabbing is stopped using StopGrabbing().  

        """
        return _pylon.InstantCamera_GrabOne(self, *args)

    def GetQueuedBufferCount(self):
        r"""


        Deprecated: This method has been deprecated. Use the NumQueuedBuffers parameter
        instead.  

        Returns
        -------
        The number of buffers that are queued for grabbing.  

        """
        return _pylon.InstantCamera_GetQueuedBufferCount(self)

    def GetGrabResultWaitObject(self):
        r"""


        Provides access to a wait object indicating available grab results.  

        Returns
        -------
        A wait object indicating available grab results.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetGrabResultWaitObject(self)

    def GetGrabStopWaitObject(self):
        r"""


        Provides access to a wait object indicating that the grabbing has stopped.  

        Returns
        -------
        A wait object indicating that the grabbing has stopped.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetGrabStopWaitObject(self)

    def GetCameraEventWaitObject(self):
        r"""


        Provides access to a wait object indicating available camera events.  

        This wait object is Pylon device specific and changes when a new Pylon device is
        attached to the camera.  

        Returns
        -------
        A wait object indicating available camera events.  

        pre:  

            *   A Pylon device is attached.  
            *   The Pylon device is open.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetCameraEventWaitObject(self)

    def RegisterConfiguration(self, pConfigurator, mode, cleanupProcedure):
        r"""


        Adds a configurator to the list of registered configurator objects.  

        *   If mode equals RegistrationMode_ReplaceAll, the list of registered
            configurators is cleared.  
        *   If pointer `pConfigurator` is not NULL, it is appended to the list of
            configurators.  

        Parameters
        ----------
        * `pConfigurator` :  
            The receiver of configuration events.  
        * `mode` :  
            Indicates how to register the new configurator.  
        * `cleanupProcedure` :  
            If cleanupProcedure equals Cleanup_Delete, the passed event handler is
            deleted when no longer needed.  

        post: The configurator is registered and called on configuration events.  

        Does not throw C++ exceptions, except when memory allocation fails.  

        This method is synchronized using the lock provided by GetLock().  

        """

        if cleanupProcedure == Cleanup_Delete:
            pConfigurator.__disown__()
        elif cleanupProcedure == Cleanup_None:
        # should we increment the pyhon refcount here??
            pass


        return _pylon.InstantCamera_RegisterConfiguration(self, pConfigurator, mode, cleanupProcedure)


    def DeregisterConfiguration(self, configurator):
        r"""


        Removes a configurator from the list of registered configurator objects.  

        If the configurator is not found, nothing is done.  

        Parameters
        ----------
        * `configurator` :  
            The registered receiver of configuration events.  

        Returns
        -------
        True if successful  

        post:  

            *   The configurator is deregistered.  
            *   If the configuration has been registered by passing a pointer and the
                cleanup procedure is Cleanup_Delete, the event handler is deleted.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_DeregisterConfiguration(self, configurator)

    def RegisterImageEventHandler(self, pImageEventHandler, mode, cleanupProcedure):
        r"""


        Adds an image event handler to the list of registered image event handler
        objects.  

        *   If mode equals RegistrationMode_ReplaceAll, the list of registered image
            event handlers is cleared.  
        *   If pointer `pImageEventHandler` is not NULL, it is appended to the list of
            image event handlers.  

        Parameters
        ----------
        * `pImageEventHandler` :  
            The receiver of image events.  
        * `mode` :  
            Indicates how to register the new imageEventHandler.  
        * `cleanupProcedure` :  
            If cleanupProcedure equals Cleanup_Delete, the passed event handler is
            deleted when no longer needed.  

        post: The imageEventHandler is registered and called on image related events.  

        Does not throw C++ exceptions, except when memory allocation fails.  

        This method is synchronized using the internal image event handler registry
        lock.  

        """

        if cleanupProcedure == Cleanup_Delete:
            pImageEventHandler.__disown__()
        elif cleanupProcedure == Cleanup_None:
        # should we increment the pyhon refcount here??
            pass


        return _pylon.InstantCamera_RegisterImageEventHandler(self, pImageEventHandler, mode, cleanupProcedure)


    def DeregisterImageEventHandler(self, imageEventHandler):
        r"""


        Removes an image event handler from the list of registered image event handler
        objects.  

        If the image event handler is not found, nothing is done.  

        Parameters
        ----------
        * `imageEventHandler` :  
            The registered receiver of configuration events.  

        Returns
        -------
        True if successful  

        post:  

            *   The imageEventHandler is deregistered.  
            *   If the image event handler has been registered by passing a pointer and
                the cleanup procedure is Cleanup_Delete, the event handler is deleted.  

        Does not throw C++ exceptions.  

        This method is synchronized using the internal image event handler registry
        lock.  

        """
        return _pylon.InstantCamera_DeregisterImageEventHandler(self, imageEventHandler)

    def RegisterCameraEventHandler(self, *args):
        r"""


        Adds an camera event handler to the list of registered camera event handler
        objects.  

        *   If mode equals RegistrationMode_ReplaceAll, the list of registered camera
            event handlers is cleared.  
        *   If the pointer `pCameraEventHandler` is not NULL, it is appended to the list
            of camera event handlers.  

        Parameters
        ----------
        * `pCameraEventHandler` :  
            The receiver of camera events.  
        * `nodeName` :  
            The name of the event data node updated on camera event, e.g.
            "ExposureEndEventTimestamp" for exposure end event.  
        * `userProvidedId` :  
            This ID is passed as a parameter in CCameraEventHandler::OnCameraEvent and
            can be used to distinguish between different events. It is recommended to
            create an own application specific enum and use it's values as IDs.  
        * `mode` :  
            Indicates how to register the new cameraEventHandler.  
        * `cleanupProcedure` :  
            If cleanupProcedure equals Cleanup_Delete, the passed event handler is
            deleted when no longer needed.  
        * `availability` :  
            If availability equals CameraEventAvailability_Mandatory, the camera must
            support the data node specified by node name. If not, an exception is thrown
            when the Instant Camera is open, the Instant Camera is opened, or an open
            Pylon device is attached.  

        Internally, a GenApi node call back is registered for the node identified by
        `nodeName`. This callback triggers a call to the
        `CCameraEventHandler::OnCameraEvent()` method. That's why a Camera Event Handler
        can be registered for any node of the camera node map to get informed about
        changes.  

        post: The cameraEventHandler is registered and called on camera events.  

        Throws an exception if the availability is set to
        CameraEventAvailability_Mandatory and the node with the name `nodeName` is not
        available in the camera node map (see GetNodeMap()). Throws an exception fail if
        the node callback registration fails. The event handler is not registered when
        an C++ exception is thrown.  

        This method is synchronized using the camera event handler lock. If the camera
        is open, the lock provided by GetLock() and the camera node map lock are also
        used for synchronization.  

        """

        assert(len(args) > 4)
        if args[4] == Cleanup_Delete:
            args[0].__disown__()
        elif args[4] == Cleanup_None:
        # should we increment the pyhon refcount here??
            pass


        return _pylon.InstantCamera_RegisterCameraEventHandler(self, *args)


    def DeregisterCameraEventHandler(self, cameraEventHandler, nodeName):
        r"""


        Removes a camera event handler from the list of registered camera event handler
        objects.  

        If the camera event handler is not found, nothing is done.  

        Parameters
        ----------
        * `cameraEventHandler` :  
            The registered receiver of camera events.  
        * `nodeName` :  
            The name of the event data node updated on camera event, e.g.
            "ExposureEndEventTimestamp" for exposure end event.  

        Returns
        -------
        True if successful  

        post:  

            *   The cameraEventHandler is deregistered.  
            *   If the camera event handler has been registered by passing a pointer and
                the cleanup procedure is Cleanup_Delete, the event handler is deleted.  

        Does not throw C++ exceptions.  

        This method is synchronized using the camera event handler lock. If the camera
        is open, the camera node map lock is also used for synchronization.  

        """
        return _pylon.InstantCamera_DeregisterCameraEventHandler(self, cameraEventHandler, nodeName)

    def WaitForFrameTriggerReady(self, *args):
        r"""


        Actively waits until the the camera is ready to accept a frame trigger.  

        The implementation selects 'FrameTriggerWait' for the
        'AcquisitionStatusSelector' and waits until the 'AcquisitionStatus' is true. If
        the above mentioned nodes are not available and the 'SoftwareTrigger' node is
        readable, the implementation waits for SoftwareTrigger.IsDone().  

        The WaitForFrameTriggerReady method does not work for A600 Firewire cameras.  

        Parameters
        ----------
        * `timeoutMs` :  
            The timeout in ms for active waiting.  
        * `timeoutHandling` :  
            If timeoutHandling equals TimeoutHandling_ThrowException, a timeout
            exception is thrown on timeout.  

        Returns
        -------
        True if the camera can execute a frame trigger.  

        pre: The 'AcquisitionStatusSelector' node is writable and the
            'AcquisitionStatus' node is readable or the 'SoftwareTrigger' node is
            readable. This depends on the used camera model.  

        Accessing the camera registers may fail.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_WaitForFrameTriggerReady(self, *args)

    def ExecuteSoftwareTrigger(self):
        r"""


        Executes the software trigger command.  

        The camera needs to be configured for software trigger mode. Additionally, the
        camera needs to be ready to accept triggers. When triggering a frame this can be
        checked using the WaitForFrameTriggerReady() method;  

        note: The application has to make sure that the correct trigger is selected
            before calling ExecuteSoftwareTrigger(). This can be done via the camera's
            TriggerSelector node. The `Pylon::CSoftwareTriggerConfiguration` selects the
            correct trigger when the Instant Camera is opened.  

        pre:  

            *   The grabbing is started.  
            *   The camera device supports software trigger.  
            *   The software trigger is available. This depends on the configuration of
                the camera device.  

        Accessing the camera registers may fail. Throws an exception on timeout if
        `timeoutHandling` is TimeoutHandling_ThrowException.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_ExecuteSoftwareTrigger(self)

    def SetCameraContext(self, context):
        r"""


        Sets a context that is attached to each grab result of the camera object on
        RetrieveResult(). This is useful when handling multiple cameras. It has nothing
        in common with the context passed to the stream grabber when queuing a buffer.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_SetCameraContext(self, context)

    def GetCameraContext(self):
        r"""


        Returns the context that is attached to each grab result of the camera object.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetCameraContext(self)

    def GetDeviceInfo(self):
        r"""


        Provides access to the device info object of the attached Pylon device or an
        empty one.  

        Returns
        -------
        The info object of the attached Pylon device or an empty one.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetDeviceInfo(self)

    def GetNodeMap(self):
        r"""


        Provides access to the node map of the camera device.  

        The Pylon device must be opened before reading ore writing any parameters of the
        camera device. This can be done using the Open() method of the Instant Camera
        class.  

        Returns
        -------
        Reference to the node map of the camera device.  

        pre: A Pylon device is attached.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetNodeMap(self)

    def GetTLNodeMap(self):
        r"""


        Provides access to the transport layer node map of the attached Pylon device.  

        Returns
        -------
        Reference to the transport layer node map of the attached Pylon device or the
        reference to the empty node map if a transport layer node map is not supported.
        The GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check
        whether the node map is empty.  

        pre: A Pylon device is attached.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetTLNodeMap(self)

    def GetStreamGrabberNodeMap(self):
        r"""


        Provides access to the stream grabber node map of the attached Pylon device.  

        Returns
        -------
        Reference to the stream grabber node map of the attached Pylon device or the
        reference to the empty node map if grabbing is not supported. The
        GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check whether
        the node map is empty.  

        pre:  

            *   A Pylon device is attached.  
            *   The Pylon device is open.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetStreamGrabberNodeMap(self)

    def GetEventGrabberNodeMap(self):
        r"""


        Provides access to the event grabber node map of the attached Pylon device.  

        Returns
        -------
        Reference to the event grabber node map of the attached Pylon device or a
        reference to the empty node map if event grabbing is not supported. The
        GENAPI_NAMESPACE::INodeMap::GetNumNodes() method can be used to check whether
        the node map is empty.  

        pre:  

            *   A Pylon device is attached.  
            *   The Pylon device is open.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetEventGrabberNodeMap(self)

    def GetInstantCameraNodeMap(self):
        r"""


        Provides access to the node map of the Instant Camera object.  

        The node map of the camera device is made available by the GetNodeMap() method.  

        Returns
        -------
        Reference to the node map of the Instant Camera object.  

        Does not throw C++ exceptions.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetInstantCameraNodeMap(self)

    def SetBufferFactory(self, *args):
        r"""


        Sets an alternative buffer factory that is used for buffer allocation.  

        This use of this method is optional and intended for advanced use cases only.  

        If NULL is passed as buffer factory then the default buffer factory is used.
        Buffers are allocated when StartGrabbing is called. A buffer factory must not be
        deleted while it is attached to the camera object and it must not be deleted
        until the last buffer is freed. To free all buffers the grab needs to be stopped
        and all grab results must be released or destroyed.  

        Parameters
        ----------
        * `pFactory` :  
            A pointer to a buffer factory.  
        * `cleanupProcedure` :  
            If ownership is cleanupProcedure Cleanup_Delete, the passed factory is
            destroyed when no longer needed.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_SetBufferFactory(self, *args)

    def IsGigE(self):
        r"""


        Returns true if a GigE Pylon device is attached to the Instant Camera object.  

        This method is provided for convenience only. The device type can also be
        determined as shown in the following example.  


        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsGigE(self)

    def IsUsb(self):
        r"""


        Returns true if a USB Pylon device is attached to the Instant Camera object.  

        This method is provided for convenience only. The device type can also be
        determined as shown in the following example.  


        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsUsb(self)

    def IsCameraLink(self):
        r"""


        Returns true if a Camera Link Pylon device is attached to the Instant Camera
        object.  

        This method is provided for convenience only. The device type can also be
        determined as shown in the following example.  


        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_IsCameraLink(self)

    def IsCxp(self):
        return _pylon.InstantCamera_IsCxp(self)

    def GetSfncVersion(self):
        r"""


        Returns the SFNC version read from the camera node map.  

        The SFNC version is read from the camera node map using the integer nodes
        DeviceSFNCVersionMajor, DeviceSFNCVersionMinor, and DeviceSFNCVersionSubMinor.  

        Returns
        -------
        The SFNC version used by the camera device. The returned SFNC version is 0.0.0
        (Pylon::Sfnc_VersionUndefined) if no SFNC version information is provided by the
        camera device.  

        pre: A Pylon device is attached.  

        The Instant Camera object is still valid after error.  

        This method is synchronized using the lock provided by GetLock().  

        """
        return _pylon.InstantCamera_GetSfncVersion(self)
    QueuedBufferCount = property(GetQueuedBufferCount) 
    CameraContext = property(GetCameraContext,SetCameraContext) 
    DeviceInfo = property(GetDeviceInfo) 
    NodeMap = property(GetNodeMap) 
    TLNodeMap = property(GetTLNodeMap) 
    StreamGrabberNodeMap = property(GetStreamGrabberNodeMap) 
    EventGrabberNodeMap = property(GetEventGrabberNodeMap) 
    InstantCameraNodeMap = property(GetInstantCameraNodeMap) 

    StreamGrabber = property(lambda self: self.GetStreamGrabberNodeMap() if self.IsOpen() else None)
    EventGrabber = property(lambda self: self.GetEventGrabberNodeMap() if self.IsOpen() else None)
    TransportLayer = property(lambda self: self.GetTLNodeMap())

    def __getattr__(self, attribute):
        if hasattr(InstantCameraParams_Params, attribute) or attribute in ( "thisown","this") or attribute.startswith("__"):
            return object.__getattr__(self, attribute)
        else:
            return self.GetNodeMap().GetNode(attribute)

    def __setattr__(self, attribute, val):
        if hasattr(InstantCameraParams_Params, attribute) or attribute in ( "thisown","this") or attribute.startswith("__"):
            object.__setattr__(self, attribute, val)
        else:
            warnings.warn(f"Setting a feature value by direct assignment is deprecated. Use <nodemap>.{attribute}.Value = {val}", DeprecationWarning, stacklevel=2)
            self.GetNodeMap().GetNode(attribute).SetValue(val)

    def __dir__(self):
        l = dir(type(self))
        l.extend(self.__dict__.keys())
        try:
            nodes = self.GetNodeMap().GetNodes()
            features = filter(lambda n: n.GetNode().IsFeature(), nodes)
            l.extend(x.GetNode().GetName() for x in features)
        except:
            pass
        return sorted(set(l))


# Register InstantCamera in _pylon:
_pylon.InstantCamera_swigregister(InstantCamera)
class InstantCameraArray(object):
    r"""


    Supports grabbing with multiple camera devices.  

    The CInstantCameraArray class is not thread-safe.  

    C++ includes: InstantCameraArray.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Creates an Instant Camera Array.  

        Calls Initialize() to adjust the size of the array.  

        Parameters
        ----------
        * `numberOfCameras` :  
            The number of cameras the array shall hold. Can be 0.  

        The index operator can be used to access the individual cameras for attaching a
        Pylon Device or for configuration.  

        Example:  

        Does not throw C++ exceptions, except when memory allocation fails.  

        """
        _pylon.InstantCameraArray_swiginit(self, _pylon.new_InstantCameraArray(*args))
    __swig_destroy__ = _pylon.delete_InstantCameraArray

    def Initialize(self, numberOfCameras):
        r"""


        Initializes the array.  

        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   All cameras of the array are destroyed.  
        *   A new set of cameras is created. No Pylon Devices are attached.  
        *   The camera context values are set to the index of the camera in the array
            using CInstantCamera::SetCameraContext.  

        The index operator can be used to access the individual cameras for attaching a
        Pylon Device or for configuration.  

        Parameters
        ----------
        * `numberOfCameras` :  
            The number of cameras the array shall hold.  

        Does not throw C++ exceptions, except when memory allocation fails.  

        """
        return _pylon.InstantCameraArray_Initialize(self, numberOfCameras)

    def IsPylonDeviceAttached(self):
        r"""


        Returns the attachment state of cameras in the array.  

        Returns
        -------
        True if all cameras in the array have a Pylon Device attached. False is returned
        if the size of the array is 0.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_IsPylonDeviceAttached(self)

    def IsCameraDeviceRemoved(self):
        r"""


        Returns the connection state of the camera devices used by the Instant Cameras
        in the array.  

        The device removal is only detected if the Instant Cameras and therefore the
        attached Pylon Devices are open.  

        The Pylon Device is not operable after this event. After it is made sure that no
        access to the Pylon Device or any of its node maps is made anymore the Pylon
        Device should be destroyed using InstantCamera::DeviceDestroy(). The access to
        the Pylon Device can be protected using the lock provided by GetLock(), e.g.
        when accessing parameters.  

        Returns
        -------
        True if the camera device removal from the PC for any camera in the array has
        been detected.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_IsCameraDeviceRemoved(self)

    def DestroyDevice(self):
        r"""


        Destroys the Pylon Devices that are attached to the Instant Cameras in the
        array.  

        attention: The node maps, e.g. the camera node map, of the attached Pylon Device
            must not be accessed anymore while destroying the Pylon Device.  

        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   DestroyDevice is called for all cameras. See CInstantCamera::DestroyDevice()
            for more information.  

        post: No Pylon Devices are attached to the cameras in the array.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_DestroyDevice(self)

    def DetachDevice(self):
        r"""


        Detaches all Pylon Devices that are attached to the Instant Cameras in the
        array.  

        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   DetachDevice is called for all cameras, see CInstantCamera::DetachDevice()
            for more information.  

        post:  

            *   No Pylon Devices are attached to the cameras in the array.  
            *   The ownership of the Pylon Devices goes to the caller who is responsible
                for destroying the Pylon Devices.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_DetachDevice(self)

    def Open(self):
        r"""


        Opens all cameras in the array.  

        Open is called for all cameras. See CInstantCamera::Open() for more information.  

        pre:  

            *   The size of the array is larger than 0.  
            *   All devices are attached.  

        post: The cameras are open.  

        If one camera throws an exception, all cameras are closed by calling Close().  

        """
        return _pylon.InstantCameraArray_Open(self)

    def IsOpen(self):
        r"""


        Returns the open state of the cameras in the array.  Does not throw C++
        exceptions.  

        Returns
        -------
        Returns true if all cameras in the array are open. False is returned if the size
        of the array is 0.  

        """
        return _pylon.InstantCameraArray_IsOpen(self)

    def Close(self):
        r"""


        Closes all cameras in the array.  

        *   If a grab is in progress, it is stopped by calling StopGrabbing().  
        *   Close is called for all cameras, see CInstantCamera::Close() for more
            information.  

        post: All cameras in the array are closed.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_Close(self)

    def GetSize(self):
        r"""


        Returns the size of the array.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_GetSize(self)

    def __getitem__(self, index):

        if index >= self.GetSize():
            raise IndexError


        return _pylon.InstantCameraArray___getitem__(self, index)


    def StartGrabbing(self, *args):
        r"""


        Starts the grabbing of images for all cameras.  

        *   StartGrabbing is called for all cameras with the provided parameters, see
            CInstantCamera::StartGrabbing() for more information.  
        *   The grabbing is started.  
        *   The starting position for retrieving results is set to the first camera.  

        Parameters
        ----------
        * `strategy` :  
            The grab strategy, see Pylon::InstantCamera::EStrategy for more information.  
        * `grabLoopType` :  
            Indicates using the internal grab thread of the camera.  

        pre:  

            *   The size of the array is larger than 0.  
            *   All devices are attached.  
            *   The grabbing is stopped.  
            *   The preconditions for calling StartGrabbing() are met for every camera
                in the array.  

        post: The grabbing is started.  

        The camera objects may throw an exception. The grabbing is stopped calling
        StopGrabbing() in this case.  

        """
        return _pylon.InstantCameraArray_StartGrabbing(self, *args)

    def RetrieveResult(self, *args):
        r"""


        Retrieves a grab result according to the strategy, waits if it is not yet
        available.  

        *   The content of the passed grab result is released.  
        *   If the grabbing is not started, the method returns immediately false.  
        *   If GrabStrategy_UpcomingImage strategy: RetrieveResult is called for a
            camera. Cameras are processed using a round-robin strategy.  
        *   If GrabStrategy_OneByOne, GrabStrategy_LatestImageOnly or
            GrabStrategy_LatestImages strategy: Pending images or camera events are
            retrieved. Cameras are processed using a round-robin strategy.  
        *   If GrabStrategy_OneByOne, GrabStrategy_LatestImageOnly or
            GrabStrategy_LatestImages strategy: Wait for a grab result if it is not yet
            available. Camera events are handled.  

        The camera array index is assigned to the context value of the instant camera
        when Initialize() is called. This context value is attached to the result when
        the result is retrieved and can be obtained using the grab result method
        GrabResultData::GetCameraContext(). The context value can be used to associate
        the result with the camera from where it originated.  

        Parameters
        ----------
        * `timeoutMs` :  
            A timeout value in ms for waiting for a grab result, or the INFINITE value.  
        * `grabResult` :  
            Receives the grab result.  
        * `timeoutHandling` :  
            If timeoutHandling equals TimeoutHandling_ThrowException, a timeout
            exception is thrown on timeout.  

        Returns
        -------
        True if the call successfully retrieved a grab result, false otherwise.  

        pre: The preconditions for calling StartGrabbing() are met for every camera in
            the array.  

        post:  

            *   If successful, one image is removed from the output queue of a camera
                and is returned in the grabResult parameter.  
            *   If not successful, an empty grab result is returned in the grabResult
                parameter.  

        The Instant Camera Array object is still valid after error. The grabbing is
        stopped by calling StopGrabbing() if an exception is thrown.  

        """
        return _pylon.InstantCameraArray_RetrieveResult(self, *args)

    def StopGrabbing(self):
        r"""


        Stops the grabbing of images.  

        The grabbing is stopped. StopGrabbing is called for all cameras. See
        CInstantCamera::StopGrabbing() for more information.  

        post: The grabbing is stopped.  

        Does not throw C++ exceptions.  

        Can be called while one other thread is polling RetrieveResult() in a
        IsGrabbing()/RetrieveResult() loop to stop grabbing.  

        """
        return _pylon.InstantCameraArray_StopGrabbing(self)

    def IsGrabbing(self):
        r"""


        Returns state of grabbing.  

        The camera array is grabbing after a successful call to StartGrabbing() until
        StopGrabbing() has been called.  

        Returns
        -------
        Returns true if still grabbing.  

        Does not throw C++ exceptions.  

        """
        return _pylon.InstantCameraArray_IsGrabbing(self)

# Register InstantCameraArray in _pylon:
_pylon.InstantCameraArray_swigregister(InstantCameraArray)
class ImageEventHandler(object):
    r"""


    The image event handler base class.  

    C++ includes: ImageEventHandler.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def OnImagesSkipped(self, camera, countOfSkippedImages):
        r"""


        This method is called when images have been skipped using the
        GrabStrategy_LatestImageOnly strategy or the GrabStrategy_LatestImages strategy.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `countOfSkippedImages` :  
            The number of images skipped. This `countOfSkippedImages` does not include
            the number of images lost in the case of a buffer under run in the driver.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called outside the lock of the camera object but inside the lock
        of the image event handler registry.  

        """
        return _pylon.ImageEventHandler_OnImagesSkipped(self, camera, countOfSkippedImages)

    def OnImageGrabbed(self, camera, grabResult):
        r"""


        This method is called when an image has been grabbed.  

        The grab result smart pointer passed does always reference a grab result data
        object. The status of the grab needs to be checked before accessing the grab
        result data. See CGrabResultData::GrabSucceeded(),
        CGrabResultData::GetErrorCode() and CGrabResultData::GetErrorDescription() for
        more information.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `grabResult` :  
            The grab result data.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called outside the lock of the camera object but inside the lock
        of the image event handler registry.  

        """
        return _pylon.ImageEventHandler_OnImageGrabbed(self, camera, grabResult)

    def OnImageEventHandlerRegistered(self, camera):
        r"""


        This method is called when the image event handler has been registered.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through.  This method is called inside
        the lock of the image event handler registry.  

        """
        return _pylon.ImageEventHandler_OnImageEventHandlerRegistered(self, camera)

    def OnImageEventHandlerDeregistered(self, camera):
        r"""


        This method is called when the image event handler has been deregistered.  

        The image event handler is automatically deregistered when the Instant Camera
        object is destroyed.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored.  This method is called
        inside the lock of the image event handler registry.  

        """
        return _pylon.ImageEventHandler_OnImageEventHandlerDeregistered(self, camera)

    def DestroyImageEventHandler(self):
        r"""


        Destroys the image event handler.  

        C++ exceptions from this call will be caught and ignored.  

        """
        return _pylon.ImageEventHandler_DestroyImageEventHandler(self)

    def __init__(self, *args):
        r"""


        Copy.  

        """
        if self.__class__ == ImageEventHandler:
            _self = None
        else:
            _self = self
        _pylon.ImageEventHandler_swiginit(self, _pylon.new_ImageEventHandler(_self, *args))
    __swig_destroy__ = _pylon.delete_ImageEventHandler
    def __disown__(self):
        self.this.disown()
        _pylon.disown_ImageEventHandler(self)
        return weakref.proxy(self)

# Register ImageEventHandler in _pylon:
_pylon.ImageEventHandler_swigregister(ImageEventHandler)
class ConfigurationEventHandler(object):
    r"""


    The configuration event handler base class.  

    C++ includes: ConfigurationEventHandler.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def OnAttach(self, camera):
        r"""


        This method is called before a Pylon Device (Pylon::IPylonDevice) is attached by
        calling the Instant Camera object's Attach() method.  

        This method can not be used for detecting that a camera device has been attached
        to the PC. The camera's Attach() method must not be called from here or from
        subsequent calls to avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnAttach(self, camera)

    def OnAttached(self, camera):
        r"""


        This method is called after a Pylon Device (Pylon::IPylonDevice) has been
        attached by calling the Instant Camera object's Attach() method.  

        This method can not be used for detecting that a camera device has been attached
        to the PC. The camera's Attach() method must not be called from here or from
        subsequent calls to avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnAttached(self, camera)

    def OnDetach(self, camera):
        r"""


        This method is called before the attached Pylon Device is detached from the
        Instant Camera object.  

        The camera's Detach() method must not be called from here or from subsequent
        calls to avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnDetach(self, camera)

    def OnDetached(self, camera):
        r"""


        This method is called after the attached Pylon Device has been detached from the
        Instant Camera object.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnDetached(self, camera)

    def OnDestroy(self, camera):
        r"""


        This method is called before the attached Pylon Device is destroyed.  

        Camera DestroyDevice must not be called from here or from subsequent calls to
        avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnDestroy(self, camera)

    def OnDestroyed(self, camera):
        r"""


        This method is called after the attached Pylon Device has been destroyed.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnDestroyed(self, camera)

    def OnOpen(self, camera):
        r"""


        This method is called before the attached Pylon Device is opened.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnOpen(self, camera)

    def OnOpened(self, camera):
        r"""


        This method is called after the attached Pylon Device has been opened.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnOpened(self, camera)

    def OnClose(self, camera):
        r"""


        This method is called before the attached Pylon Device is closed.  

        Camera Close must not be called from here or from subsequent calls to avoid
        infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnClose(self, camera)

    def OnClosed(self, camera):
        r"""


        This method is called after the attached Pylon Device has been closed.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnClosed(self, camera)

    def OnGrabStart(self, camera):
        r"""


        This method is called before a grab session is started.  

        Camera StartGrabbing must not be called from here or from subsequent calls to
        avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnGrabStart(self, camera)

    def OnGrabStarted(self, camera):
        r"""


        This method is called after a grab session has been started.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnGrabStarted(self, camera)

    def OnGrabStop(self, camera):
        r"""


        This method is called before a grab session is stopped.  

        Camera StopGrabbing must not be called from here or from subsequent calls to
        avoid infinite recursion.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnGrabStop(self, camera)

    def OnGrabStopped(self, camera):
        r"""


        This method is called after a grab session has been stopped.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnGrabStopped(self, camera)

    def OnGrabError(self, camera, errorMessage):
        r"""


        This method is called when an exception has been triggered during grabbing.  

        An exception has been triggered by a grab thread. The grab will be stopped after
        this event call.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `errorMessage` :  
            The message of the exception that signaled an error during grabbing.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnGrabError(self, camera, errorMessage)

    def OnCameraDeviceRemoved(self, camera):
        r"""


        This method is called when a camera device removal from the PC has been
        detected.  

        The Pylon Device attached to the Instant Camera is not operable after this
        event. After it is made sure that no access to the Pylon Device or any of its
        node maps is made anymore the Pylon Device should be destroyed using
        InstantCamera::DeviceDestroy(). The access to the Pylon Device can be protected
        using the lock provided by GetLock(), e.g. when accessing parameters.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  

        This method is called inside the lock of the camera object from an additional
        thread.  

        """
        return _pylon.ConfigurationEventHandler_OnCameraDeviceRemoved(self, camera)

    def OnConfigurationRegistered(self, camera):
        r"""


        This method is called when the configuration event handler has been registered.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through.  This method is called inside
        the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnConfigurationRegistered(self, camera)

    def OnConfigurationDeregistered(self, camera):
        r"""


        This method is called when the configuration event handler has been
        deregistered.  

        The configuration event handler is automatically deregistered when the Instant
        Camera object is destroyed.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        C++ exceptions from this call will be caught and ignored.  This method is called
        inside the lock of the camera object.  

        """
        return _pylon.ConfigurationEventHandler_OnConfigurationDeregistered(self, camera)

    def DestroyConfiguration(self):
        r"""


        Destroys the configuration event handler.  

        C++ exceptions from this call will be caught and ignored.  

        """
        return _pylon.ConfigurationEventHandler_DestroyConfiguration(self)

    def __init__(self, *args):
        r"""


        Copy.  

        """
        if self.__class__ == ConfigurationEventHandler:
            _self = None
        else:
            _self = self
        _pylon.ConfigurationEventHandler_swiginit(self, _pylon.new_ConfigurationEventHandler(_self, *args))
    __swig_destroy__ = _pylon.delete_ConfigurationEventHandler
    def __disown__(self):
        self.this.disown()
        _pylon.disown_ConfigurationEventHandler(self)
        return weakref.proxy(self)

# Register ConfigurationEventHandler in _pylon:
_pylon.ConfigurationEventHandler_swigregister(ConfigurationEventHandler)
class CameraEventHandler(object):
    r"""


    The camera event handler base class.  

    C++ includes: CameraEventHandler.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def OnCameraEvent(self, camera, userProvidedId, pNode):
        r"""


        This method is called when a camera event has been received.  

        Only very short processing tasks should be performed by this method. Otherwise,
        the event notification will block the processing of images.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `userProvidedId` :  
            The ID passed when registering for the event. It can be used to distinguish
            between different events.  
        * `pNode` :  
            The node identified by node name when registering.  

        C++ exceptions from this call will be caught and ignored. All event handlers are
        notified.  This method is called outside the lock of the camera object, outside
        the lock of the node map, and inside the lock of the camera event handler
        registry.  

        """
        return _pylon.CameraEventHandler_OnCameraEvent(self, camera, userProvidedId, pNode)

    def OnCameraEventHandlerRegistered(self, camera, nodeName, userProvidedId):
        r"""


        This method is called when the camera event handler has been registered.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `nodeName` :  
            The name of the event data node updated on camera event, e.g.
            "ExposureEndEventTimestamp" for exposure end event.  
        * `userProvidedId` :  
            This ID is passed as a parameter in CCameraEventHandler::OnCameraEvent and
            can be used to distinguish between different events.  

        Exceptions from this call will propagate through.  This method is called inside
        the lock of the camera event handler registry.  

        """
        return _pylon.CameraEventHandler_OnCameraEventHandlerRegistered(self, camera, nodeName, userProvidedId)

    def OnCameraEventHandlerDeregistered(self, camera, nodeName, userProvidedId):
        r"""


        This method is called when the camera event handler has been deregistered.  

        The camera event handler is automatically deregistered when the Instant Camera
        object is destroyed.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  
        * `nodeName` :  
            The name of the event data node updated on camera event, e.g.
            "ExposureEndEventTimestamp" for exposure end event.  
        * `userProvidedId` :  
            This ID is passed as a parameter in CCameraEventHandler::OnCameraEvent and
            can be used to distinguish between different events.  

        C++ exceptions from this call will be caught and ignored.  This method is called
        inside the lock of the camera event handler registry.  

        """
        return _pylon.CameraEventHandler_OnCameraEventHandlerDeregistered(self, camera, nodeName, userProvidedId)

    def DestroyCameraEventHandler(self):
        r"""


        Destroys the camera event handler.  

        C++ exceptions from this call will be caught and ignored.  

        """
        return _pylon.CameraEventHandler_DestroyCameraEventHandler(self)

    def __init__(self, *args):
        r"""


        Copy.  

        """
        if self.__class__ == CameraEventHandler:
            _self = None
        else:
            _self = self
        _pylon.CameraEventHandler_swiginit(self, _pylon.new_CameraEventHandler(_self, *args))
    __swig_destroy__ = _pylon.delete_CameraEventHandler
    def __disown__(self):
        self.this.disown()
        _pylon.disown_CameraEventHandler(self)
        return weakref.proxy(self)

# Register CameraEventHandler in _pylon:
_pylon.CameraEventHandler_swigregister(CameraEventHandler)
class SoftwareTriggerConfiguration(ConfigurationEventHandler):
    r"""


    Changes the configuration of the camera so that the acquisition of frames is
    triggered by software trigger. Use together with
    CInstantCamera::WaitForFrameTriggerReady() and
    CInstantCamera::ExecuteSoftwareTrigger().  

    The CSoftwareTriggerConfiguration is provided as header-only file. The code can
    be copied and modified for creating own configuration classes.  

    C++ includes: SoftwareTriggerConfiguration.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def ApplyConfiguration(nodemap):
        r"""


        Apply software trigger configuration.  

        """
        return _pylon.SoftwareTriggerConfiguration_ApplyConfiguration(nodemap)

    def OnOpened(self, camera):
        r"""


        This method is called after the attached Pylon Device has been opened.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.SoftwareTriggerConfiguration_OnOpened(self, camera)

    def __init__(self):
        _pylon.SoftwareTriggerConfiguration_swiginit(self, _pylon.new_SoftwareTriggerConfiguration())
    __swig_destroy__ = _pylon.delete_SoftwareTriggerConfiguration

# Register SoftwareTriggerConfiguration in _pylon:
_pylon.SoftwareTriggerConfiguration_swigregister(SoftwareTriggerConfiguration)
class AcquireContinuousConfiguration(ConfigurationEventHandler):
    r"""


    Changes the configuration of the camera to free-running continuous acquisition.  

    The `CAcquireContinuousConfiguration` is the default configuration of the
    Instant Camera class. The CAcquireContinuousConfiguration is automatically
    registered when an Instant Camera object is created.  

    This instant camera configuration is provided as header-only file. The code can
    be copied and modified for creating own configuration classes.  

    C++ includes: AcquireContinuousConfiguration.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_AcquireContinuousConfiguration

    @staticmethod
    def ApplyConfiguration(nodemap):
        r"""


        Apply acquire continuous configuration.  

        """
        return _pylon.AcquireContinuousConfiguration_ApplyConfiguration(nodemap)

    def OnOpened(self, camera):
        r"""


        This method is called after the attached Pylon Device has been opened.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.AcquireContinuousConfiguration_OnOpened(self, camera)

    def __init__(self):
        _pylon.AcquireContinuousConfiguration_swiginit(self, _pylon.new_AcquireContinuousConfiguration())

# Register AcquireContinuousConfiguration in _pylon:
_pylon.AcquireContinuousConfiguration_swigregister(AcquireContinuousConfiguration)
class AcquireSingleFrameConfiguration(ConfigurationEventHandler):
    r"""


    An instant camera configuration for single frame acquisition, Use together with
    CInstantCamera::GrabOne() only.  

    The CAcquireSingleFrameConfiguration is provided as header-only file. The code
    can be copied and modified for creating own configuration classes.  

    note: Grabbing single images using Software Trigger
        (CSoftwareTriggerConfiguration) is recommended if you want to maximize frame
        rate. This is because the overhead per grabbed image is reduced compared to
        Single Frame Acquisition. The grabbing can be started using
        CInstantCamera::StartGrabbing(). Images are grabbed using the
        CInstantCamera::WaitForFrameTriggerReady(),
        CInstantCamera::ExecuteSoftwareTrigger() and
        CInstantCamera::RetrieveResult() methods instead of using
        CInstantCamera::GrabOne(). The grab can be stopped using
        CInstantCamera::StopGrabbing() when done.  

    C++ includes: AcquireSingleFrameConfiguration.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_AcquireSingleFrameConfiguration

    @staticmethod
    def ApplyConfiguration(nodemap):
        r"""


        Apply acquire single frame configuration.  

        """
        return _pylon.AcquireSingleFrameConfiguration_ApplyConfiguration(nodemap)

    def OnOpened(self, camera):
        r"""


        This method is called after the attached Pylon Device has been opened.  

        Parameters
        ----------
        * `camera` :  
            The source of the call.  

        Exceptions from this call will propagate through. The notification of event
        handlers stops when an exception is triggered.  

        This method is called inside the lock of the camera object.  

        """
        return _pylon.AcquireSingleFrameConfiguration_OnOpened(self, camera)

    def __init__(self):
        _pylon.AcquireSingleFrameConfiguration_swiginit(self, _pylon.new_AcquireSingleFrameConfiguration())

# Register AcquireSingleFrameConfiguration in _pylon:
_pylon.AcquireSingleFrameConfiguration_swigregister(AcquireSingleFrameConfiguration)
class ActionTriggerConfiguration(ConfigurationEventHandler):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pylon.ActionTriggerConfiguration_swiginit(self, _pylon.new_ActionTriggerConfiguration(*args))
    __swig_destroy__ = _pylon.delete_ActionTriggerConfiguration

    @staticmethod
    def ApplyConfiguration(*args):
        return _pylon.ActionTriggerConfiguration_ApplyConfiguration(*args)

# Register ActionTriggerConfiguration in _pylon:
_pylon.ActionTriggerConfiguration_swigregister(ActionTriggerConfiguration)
AllGroupMask = cvar.AllGroupMask

ImageFileFormat_Tiff = _pylon.ImageFileFormat_Tiff
ImageFileFormat_Png = _pylon.ImageFileFormat_Png
ImageFileFormat_Raw = _pylon.ImageFileFormat_Raw
ImageFileFormat_Dng = _pylon.ImageFileFormat_Dng
class ImagePersistenceOptions(object):
    r"""


    Used to pass options to CImagePersistence methods.  

    C++ includes: ImagePersistence.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        """
        _pylon.ImagePersistenceOptions_swiginit(self, _pylon.new_ImagePersistenceOptions())
    __swig_destroy__ = _pylon.delete_ImagePersistenceOptions

    def SetQuality(self, quality):
        r"""


        Set the image quality options. Valid quality values range from 0 to 100.  

        """
        return _pylon.ImagePersistenceOptions_SetQuality(self, quality)

    def GetQuality(self):
        r"""


        Returns the set quality level.  

        """
        return _pylon.ImagePersistenceOptions_GetQuality(self)

# Register ImagePersistenceOptions in _pylon:
_pylon.ImagePersistenceOptions_swigregister(ImagePersistenceOptions)
ImageOrientation_TopDown = _pylon.ImageOrientation_TopDown
ImageOrientation_BottomUp = _pylon.ImageOrientation_BottomUp
class Image(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_Image

    def IsValid(self):
        return _pylon.Image_IsValid(self)

    def GetPixelType(self):
        return _pylon.Image_GetPixelType(self)

    def GetWidth(self):
        return _pylon.Image_GetWidth(self)

    def GetHeight(self):
        return _pylon.Image_GetHeight(self)

    def GetPaddingX(self):
        return _pylon.Image_GetPaddingX(self)

    def GetOrientation(self):
        return _pylon.Image_GetOrientation(self)

    def GetBuffer(self):
        return _pylon.Image_GetBuffer(self)

    def GetImageSize(self):
        return _pylon.Image_GetImageSize(self)

    def IsUnique(self):
        return _pylon.Image_IsUnique(self)

    def GetStride(self, strideBytes):
        return _pylon.Image_GetStride(self, strideBytes)

# Register Image in _pylon:
_pylon.Image_swigregister(Image)

IImage = Image

class IReusableImage(Image):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylon.delete_IReusableImage

    def IsSupportedPixelType(self, pixelType):
        return _pylon.IReusableImage_IsSupportedPixelType(self, pixelType)

    def IsAdditionalPaddingSupported(self):
        return _pylon.IReusableImage_IsAdditionalPaddingSupported(self)

    def Reset(self, *args):
        return _pylon.IReusableImage_Reset(self, *args)

    def Release(self):
        return _pylon.IReusableImage_Release(self)

# Register IReusableImage in _pylon:
_pylon.IReusableImage_swigregister(IReusableImage)
class PylonImageBase(IReusableImage):
    r"""


    Provides basic functionality for pylon image classes.  

    C++ includes: PylonImageBase.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Save(self, imageFileFormat, filename, pOptions=None):
        r"""


        Saves the image to disk. Converts the image to a format that can be saved if
        required.  

        This is a convenience method that calls CImagePersistence::Save().  

        If required, the image is automatically converted into a new image and saved
        afterwards. See CImagePersistence::CanSaveWithoutConversion() for more
        information. An image with a bit depth higher than 8 bit is stored with 16 bit
        bit depth, if supported by the image file format. In this case the pixel data is
        MSB aligned.  

        If more control over the conversion is required, the CImageFormatConverter class
        can be used to convert the input image before saving it.  

        Parameters
        ----------
        * `imageFileFormat` :  
            File format to save the image in.  
        * `filename` :  
            Name and path of the image.  
        * `pOptions` :  
            Additional options.  

        pre: The pixel type of the image to be saved must be a supported input format of
            the Pylon::CImageFormatConverter.  

        Throws an exception if the saving of the image fails.  

        """
        return _pylon.PylonImageBase_Save(self, imageFileFormat, filename, pOptions)

    def Load(self, filename):
        r"""


        Loads an image from a disk.  

        This is a convenience method that calls CImagePersistence::Load()  

        Parameters
        ----------
        * `filename` :  
            Name and path of the image.  

        pre: The image object must be able to hold the image format of the loaded image.  

        Throws an exception if the image cannot be loaded. The image buffer content is
        undefined when the loading of the image fails.  

        """
        return _pylon.PylonImageBase_Load(self, filename)

    def CanSaveWithoutConversion(self, imageFileFormat):
        r"""


        Can be used to check whether the image can be saved without prior conversion.  

        This is a convenience method that calls
        CImagePersistence::CanSaveWithoutConversion().  

        Parameters
        ----------
        * `imageFileFormat` :  
            Target file format for the image to be saved.  

        Returns
        -------
        Returns true, if the image can be saved without prior conversion.  

        Does not throw C++ exceptions.  

        """
        return _pylon.PylonImageBase_CanSaveWithoutConversion(self, imageFileFormat)

    def GetPixelData(self, posX, posY):
        r"""


        Retrieves the data of a pixel.  

        note: This method is relativly slow. Do not use it for image processing tasks.  

        Parameters
        ----------
        * `posX` :  
            Horizontal position of the pixel. The first column has position 0.  
        * `posY` :  
            Vertical position of the pixel. The first row has position 0.  

        Returns
        -------
        Returns the data of a pixel for supported pixel types. For unsupported pixel
        types pixel data of the SPixelData::PixelDataType_Unknown type is returned.  

        pre:  

            *   The image must be valid.  
            *   The pixel position defined by `posX` and `posY` must be located inside
                the image area.  

        Supported pixel types:  

        *   PixelType_Mono1packed  
        *   PixelType_Mono2packed  
        *   PixelType_Mono4packed  
        *   PixelType_Mono8  
        *   PixelType_Mono8signed  
        *   PixelType_Mono10  
        *   PixelType_Mono10packed  
        *   PixelType_Mono10p  
        *   PixelType_Mono12  
        *   PixelType_Mono12packed  
        *   PixelType_Mono12p  
        *   PixelType_Mono16  

        *   PixelType_BayerGR8  
        *   PixelType_BayerRG8  
        *   PixelType_BayerGB8  
        *   PixelType_BayerBG8  
        *   PixelType_BayerGR10  
        *   PixelType_BayerRG10  
        *   PixelType_BayerGB10  
        *   PixelType_BayerBG10  
        *   PixelType_BayerGR12  
        *   PixelType_BayerRG12  
        *   PixelType_BayerGB12  
        *   PixelType_BayerBG12  
        *   PixelType_BayerGR12Packed  
        *   PixelType_BayerRG12Packed  
        *   PixelType_BayerGB12Packed  
        *   PixelType_BayerBG12Packed  
        *   PixelType_BayerGR10p  
        *   PixelType_BayerRG10p  
        *   PixelType_BayerGB10p  
        *   PixelType_BayerBG10p  
        *   PixelType_BayerGR12p  
        *   PixelType_BayerRG12p  
        *   PixelType_BayerGB12p  
        *   PixelType_BayerBG12p  
        *   PixelType_BayerGR16  
        *   PixelType_BayerRG16  
        *   PixelType_BayerGB16  
        *   PixelType_BayerBG16  

        *   PixelType_RGB8packed  
        *   PixelType_BGR8packed  
        *   PixelType_RGBA8packed  
        *   PixelType_BGRA8packed  
        *   PixelType_RGB10packed  
        *   PixelType_BGR10packed  
        *   PixelType_RGB12packed  
        *   PixelType_BGR12packed  
        *   PixelType_RGB12V1packed  
        *   PixelType_RGB16packed  
        *   PixelType_RGB8planar  
        *   PixelType_RGB10planar  
        *   PixelType_RGB12planar  
        *   PixelType_RGB16planar  

        *   PixelType_YUV422packed  
        *   PixelType_YUV422_YUYV_Packed  

        Throws an exception, if the preconditions are not met.  

        """
        return _pylon.PylonImageBase_GetPixelData(self, posX, posY)

# Register PylonImageBase in _pylon:
_pylon.PylonImageBase_swigregister(PylonImageBase)

from contextlib import contextmanager
import sys

class PylonImage(PylonImageBase):
    r"""


    Describes an image.  

    *   Automatically handles size and lifetime of the image buffer.  
    *   Allows to take over a buffer of grab result which is preventing its reuse as
        long as required.  
    *   Allows to connect user buffers or buffers provided by third party software
        packages.  
    *   Provides methods for loading and saving an image in different file formats.  
    *   Serves as the main target format for the image format converter
        `CImageFormatConverter`.  
    *   Eases working with planar images.  
    *   Eases extraction of AOIs, e.g. for thumbnail images of defects.  

    par: Buffer Handling:
        The buffer that is automatically created by the CPylonImage class or a
        hosted grab result buffer are replaced by a larger buffer if required. The
        size of the allocated buffer is never decreased. Referenced user buffers are
        never automatically replaced by a larger buffer. Referenced grab result
        buffers are never reused. See the Reset() method for more details. The
        Release() method can be used to detach a user buffer, release a hosted grab
        result buffer or to free an allocated buffer.  

    The CPylonImage class is not thread-safe.  

    C++ includes: PylonImage.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""


        Copies the image properties and creates a reference to the buffer of the source
        image.  

        Parameters
        ----------
        * `source` :  
            The source image.  

        post:  

            *   Another reference to the source image buffer is created.  
            *   Creates an invalid image if the source image is invalid.  

        Does not throw C++ exceptions.  

        """
        _pylon.PylonImage_swiginit(self, _pylon.new_PylonImage(*args))
    __swig_destroy__ = _pylon.delete_PylonImage

    @staticmethod
    def Create(*args):
        r"""


        Creates an image and allocates a buffer for it.  

        Parameters
        ----------
        * `pixelType` :  
            The pixel type of the new image.  
        * `width` :  
            The number of pixels in a row in the new image.  
        * `height` :  
            The number of rows in the new image.  
        * `paddingX` :  
            The number of extra data bytes at the end of each row.  
        * `orientation` :  
            The vertical orientation of the image in the image buffer.  

        pre:  

            *   The pixel type must be valid.  
            *   The `width` value must be >= 0 and < _I32_MAX.  
            *   The `height` value must be >= 0 and < _I32_MAX.  

        Throws an exception when the parameters are invalid. Throws an exception when no
        buffer with the required size could be allocated.  

        """
        return _pylon.PylonImage_Create(*args)

    def CopyImage(self, *args):
        r"""


        Copies the image data from a provided buffer.  

        This method is used for making a full copy of an image. Calls the Reset() method
        to set the same image properties as the source image and copies the image data.  

        Parameters
        ----------
        * `pBuffer` :  
            The pointer to the buffer of the source image.  
        * `bufferSizeBytes` :  
            The size of the buffer of the source image.  
        * `pixelType` :  
            The pixel type of the source image.  
        * `width` :  
            The number of pixels in a row in the source image.  
        * `height` :  
            The number of rows in the source image.  
        * `paddingX` :  
            The number of extra data bytes at the end of each row.  
        * `orientation` :  
            The vertical orientation of the image in the image buffer.  

        pre:  

            *   The pixel type must be valid.  
            *   The `width` value must be >= 0 and < _I32_MAX.  
            *   The `height` value must be >= 0 and < _I32_MAX.  
            *   The pointer to the source buffer must not be NULL.  
            *   The source buffer must be large enough to hold the image described by
                the parameters.  
            *   The preconditions of the Reset() method must be met.  

        post: A copy of the image contained by the source image buffer is made.  

        Throws an exception when no buffer with the required size could be allocated.
        Throws an exception when the preconditions of the Reset() method are not met.  

        """
        return _pylon.PylonImage_CopyImage(self, *args)

    def AttachGrabResultBufferWithUserHints(self, *args):
        return _pylon.PylonImage_AttachGrabResultBufferWithUserHints(self, *args)

    def AttachGrabResultBuffer(self, grabResult):
        r"""


        Attaches a grab result buffer.  

        Parameters
        ----------
        * `grabResult` :  
            The source image represented by a grab result.  

        post:  

            *   The image properties are taken over from the grab result.  
            *   The grab result buffer is used by the image class.  
            *   Another reference to the grab result buffer is created. This prevents
                the buffer's reuse for grabbing.  
            *   Creates an invalid image if the `grabResult` is invalid.  
            *   Creates an invalid image if the grab was not successful. See
                CGrabResultData::GrabSucceeded().  

        Throws an exception when no buffer with the required size could be allocated.
        Throws an exception when the preconditions of the Reset() method are not met.  

        """
        return _pylon.PylonImage_AttachGrabResultBuffer(self, grabResult)

    def IsValid(self):
        r"""


        """
        return _pylon.PylonImage_IsValid(self)

    def GetPixelType(self):
        r"""


        """
        return _pylon.PylonImage_GetPixelType(self)

    def GetWidth(self):
        r"""


        """
        return _pylon.PylonImage_GetWidth(self)

    def GetHeight(self):
        r"""


        """
        return _pylon.PylonImage_GetHeight(self)

    def GetPaddingX(self):
        r"""


        """
        return _pylon.PylonImage_GetPaddingX(self)

    def GetOrientation(self):
        r"""


        """
        return _pylon.PylonImage_GetOrientation(self)

    def GetImageSize(self):
        r"""


        """
        return _pylon.PylonImage_GetImageSize(self)

    def IsUnique(self):
        r"""


        """
        return _pylon.PylonImage_IsUnique(self)

    def GetStride(self, strideBytes):
        r"""


        """
        return _pylon.PylonImage_GetStride(self, strideBytes)

    def IsSupportedPixelType(self, pixelType):
        r"""


        """
        return _pylon.PylonImage_IsSupportedPixelType(self, pixelType)

    def IsAdditionalPaddingSupported(self):
        r"""


        """
        return _pylon.PylonImage_IsAdditionalPaddingSupported(self)

    def Reset(self, *args):
        r"""


        Extends the Reset( EPixelType, uint32_t, uint32_t, EImageOrientation) method by
        settable paddingX.  


        Parameters
        ----------
        * `pixelType` :  
            The pixel type of the new image.  
        * `width` :  
            The number of pixels in a row in the new image.  
        * `height` :  
            The number of rows in the new image.  
        * `orientation` :  
            The vertical orientation of the image in the image buffer.  

        pre:  

            *   The `width` value must be >= 0 and < _I32_MAX.  
            *   The `height` value must be >= 0 and < _I32_MAX.  
            *   If a user buffer is referenced then this buffer must not be referenced
                by another pylon image. See the IsUnique() and IsUserBufferAttached()
                methods.  
            *   If a user buffer is referenced then this buffer must be large enough to
                hold the destination image. See the GetAllocatedBufferSize() and
                IsUserBufferAttached() methods.  

        post:  

            *   If the previously referenced buffer is a grab result buffer, a new
                buffer has been allocated.  
            *   If the previously referenced buffer is also referenced by another pylon
                image, a new buffer has been allocated.  
            *   If the previously referenced buffer is not large enough to hold an image
                with the given properties, a new buffer has been allocated.  
            *   If no buffer has been allocated before, a buffer has been allocated.  

        Throws an exception when the preconditions are not met. Throws an exception when
        no buffer with the required size could be allocated.  

        Parameters
        ----------
        * `paddingX` :  
            The number of extra data bytes at the end of each row.  

        """
        return _pylon.PylonImage_Reset(self, *args)

    def Release(self):
        r"""


        """
        return _pylon.PylonImage_Release(self)

    def IsUserBufferAttached(self):
        r"""


        Returns true if the referenced buffer has been provided by the user.  

        """
        return _pylon.PylonImage_IsUserBufferAttached(self)

    def IsGrabResultBufferAttached(self):
        r"""


        Returns true if the referenced buffer has been provided by a grab result.  

        """
        return _pylon.PylonImage_IsGrabResultBufferAttached(self)

    def GetAllocatedBufferSize(self):
        r"""


        Returns the size of the used buffer.  

        This method is useful when working with so-called user buffers.  

        Does not throw C++ exceptions.  

        """
        return _pylon.PylonImage_GetAllocatedBufferSize(self)

    def ChangePixelType(self, pixelType):
        r"""


        Changes the pixel type of the image.  

        Parameters
        ----------
        * `pixelType` :  
            The new pixel type.  

        pre:  

            *   Pylon::SamplesPerPixel( oldPixelType) == Pylon::SamplesPerPixel(
                newPixelType)  
            *   Pylon::BitPerPixel( oldPixelType) == Pylon::BitPerPixel( newPixelType)  

        Throws an exception when the new pixel type properties do not match the existing
        ones.  

        """
        return _pylon.PylonImage_ChangePixelType(self, pixelType)

    def GetPlane(self, planeIndex):
        r"""


        Creates a new pylon image for a plane of the image. No image data is copied.  

        Use CopyImage( const IImage& image) to create a full copy.  


        Parameters
        ----------
        * `planeIndex` :  
            The zero based index of the plane.  

        Returns
        -------
        A pylon image referencing a plane of the image.  

        pre: The value of planeIndex < Pylon::PlaneCount( GetPixelType()).  

        post:  

            *   A reference to the same buffer is created. No image data is copied.  
            *   The returned image has the Pylon::GetPlanePixelType( GetPixelType())
                pixel type.  
            *   If the image is not planar only index 0 is allowed. A call passing index
                0 returns a copy of the image. No image data is copied.  

        Throws an exception when the plane index is out of range.  

        """
        return _pylon.PylonImage_GetPlane(self, planeIndex)

    def GetAoi(self, topLeftX, topLeftY, width, height):
        r"""


        Creates a new pylon image for an image area of interest (Image AOI) derived from
        the image. No image data is copied.  

        Use CopyImage( const IImage& image, size_t newPaddingX) to create a full copy
        and to remove the additional padding.  


        Parameters
        ----------
        * `topLeftX` :  
            The x-coordinate of the top left corner of the image AOI in pixels.  
        * `topLeftY` :  
            The y-coordinate of the top left corner of the image AOI in pixels.  
        * `width` :  
            The width of the image AOI in pixels.  
        * `height` :  
            The height of the image AOI in pixels.  

        Returns
        -------
        A pylon image referencing an image AOI of the image.  

        pre:  

            *   The image must be valid.  
            *   The image AOI is located inside the image.  
            *   The image is not in a planar format, see Pylon::IsPlanar(). Use
                GetPlane() first in this case.  
            *   The rows of the image must be byte aligned. This may not be the case for
                packed pixel types. See Pylon::IsPacked().  
            *   The x-coordinate must be byte aligned. This may not be the case for
                packed pixel types. See Pylon::IsPacked().  
            *   The `topLeftX` parameter must be divisible by the return value of
                Pylon::GetPixelIncrementX() for the image's pixel type.  
            *   The `topLeftY` parameter must be divisible by the return value of
                Pylon::GetPixelIncrementY() for the image's pixel type.  

        post:  

            *   A reference to the same buffer is created. The image data is not copied.  
            *   The returned image uses the paddingX property to skip over image content
                outside of the image AOI.  

        Throws an exception when the preconditions are not met.  

        """
        return _pylon.PylonImage_GetAoi(self, topLeftX, topLeftY, width, height)

    def GetBuffer(self):
        r"""


        """
        return _pylon.PylonImage_GetBuffer(self)

    def GetMemoryView(self):
        return _pylon.PylonImage_GetMemoryView(self)
    0


    def AttachBytesObject(self, object, pixelType, width, height, paddingX):
        return _pylon.PylonImage_AttachBytesObject(self, object, pixelType, width, height, paddingX)


    def AttachMemoryView(self, memoryView, pixelType, width, height, paddingX):
        if memoryView.contiguous == False:
            raise ValueError("Expected a memory view with contiguous ordering")
        result = _pylon.PylonImage_AttachMemoryView(self, memoryView, pixelType, width, height, paddingX)
        if result == False:
          memoryViewBuffer = bytes(memoryView)
          _pylon.PylonImage_AttachBytesObject(self, memoryViewBuffer, pixelType, width, height, paddingX)
          self._memory_view_buffer = memoryViewBuffer # Hold buffer copy to reference to prevent garbage collection
        self._memory_view = memoryView  # Hold the reference to prevent garbage collection

    @needs_numpy
    def GetImageFormat(self, pt = None):
        if pt is None:
            pt = self.GetPixelType()
        if IsPacked(pt):
            raise ValueError("Packed Formats are not supported with numpy interface")
        if pt in ( PixelType_Mono8, PixelType_BayerGR8, PixelType_BayerRG8, PixelType_BayerGB8, PixelType_BayerBG8, PixelType_Confidence8, PixelType_Coord3D_C8 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "B"
            dtype = _pylon_numpy.uint8
        elif pt in ( PixelType_Mono10, PixelType_BayerGR10, PixelType_BayerRG10, PixelType_BayerGB10, PixelType_BayerBG10 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono12, PixelType_BayerGR12, PixelType_BayerRG12, PixelType_BayerGB12, PixelType_BayerBG12 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono16, PixelType_BayerGR16, PixelType_BayerRG16, PixelType_BayerGB16, PixelType_BayerBG16, PixelType_Confidence16, PixelType_Coord3D_C16 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_RGB8packed, PixelType_BGR8packed ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_YUV422_YUYV_Packed, PixelType_YUV422packed ):
            shape = (self.GetHeight(), self.GetWidth(), 2)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_Coord3D_ABC32f, ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.float32
            format = "f"
        else:
            raise ValueError("Pixel format currently not supported")

        return (shape, dtype, format)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.Release()

    @needs_numpy
    def AttachArray(self, array, pixeltype):
        width = array.shape[1]
        height = array.shape[0]
        paddingX = 0 # numpy has no concept of padding bytes
        self.AttachMemoryView(array.data, pixeltype, width, height, paddingX)

    @needs_numpy
    def GetArray(self, raw = False):

    # Raw case => Simple byte wrapping of buffer
        if raw:
            shape, dtype, format = ( self.GetPayloadSize() ), _pylon_numpy.uint8, "B"
            buf = self.GetBuffer()
            return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

        pt = self.GetPixelType()
        if IsPacked(pt):
            buf, new_pt = self._Unpack10or12BitPacked()
            shape, dtype, format = self.GetImageFormat(new_pt)
        else:
            shape, dtype, format = self.GetImageFormat(pt)
            buf = self.GetBuffer()

    # Now we will copy the data into an array:
        return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

    @contextmanager
    @needs_numpy
    def GetArrayZeroCopy(self, raw = False):
        '''
        Get a numpy array for the image buffer as zero copy reference to the underlying buffer.
        Note: The context manager variable MUST be released before leaving the scope.
        '''

    # For packed formats, we cannot zero-copy, so use GetArray
        pt = self.GetPixelType()
        if IsPacked(pt):
            yield self.GetArray()
            return

        mv = self.GetMemoryView()
        if not raw:
            shape, dtype, format = self.GetImageFormat()
            mv = mv.cast(format, shape)

        ar = _pylon_numpy.asarray(mv)

    # trace external references to array
        initial_refcount = sys.getrefcount(ar)

    # yield the array to the context code
        yield ar

    # detect if more refs than the one from the yield are held
        if sys.getrefcount(ar) > initial_refcount + 1:
            raise RuntimeError("Please remove any references to the array before leaving context manager scope!!!")

    # release the memory view
        mv.release()


# Register PylonImage in _pylon:
_pylon.PylonImage_swigregister(PylonImage)
InconvertibleEdgeHandling_Clip = _pylon.InconvertibleEdgeHandling_Clip
InconvertibleEdgeHandling_Extend = _pylon.InconvertibleEdgeHandling_Extend
InconvertibleEdgeHandling_SetZero = _pylon.InconvertibleEdgeHandling_SetZero
MonoConversionMethod_Gamma = _pylon.MonoConversionMethod_Gamma
MonoConversionMethod_Truncate = _pylon.MonoConversionMethod_Truncate
OutputBitAlignment_LsbAligned = _pylon.OutputBitAlignment_LsbAligned
OutputBitAlignment_MsbAligned = _pylon.OutputBitAlignment_MsbAligned
OutputOrientation_BottomUp = _pylon.OutputOrientation_BottomUp
OutputOrientation_TopDown = _pylon.OutputOrientation_TopDown
OutputOrientation_Unchanged = _pylon.OutputOrientation_Unchanged
class CImageFormatConverterParams_Params_v7_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    AdditionalLeftShift = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_AdditionalLeftShift_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_AdditionalLeftShift_set)
    Gamma = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_Gamma_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_Gamma_set)
    InconvertibleEdgeHandling = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_InconvertibleEdgeHandling_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_InconvertibleEdgeHandling_set)
    MaxNumThreads = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_MaxNumThreads_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_MaxNumThreads_set)
    MonoConversionMethod = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_MonoConversionMethod_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_MonoConversionMethod_set)
    OutputBitAlignment = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_OutputBitAlignment_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_OutputBitAlignment_set)
    OutputOrientation = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_OutputOrientation_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_OutputOrientation_set)
    OutputPaddingX = property(_pylon.CImageFormatConverterParams_Params_v7_3_1_OutputPaddingX_get, _pylon.CImageFormatConverterParams_Params_v7_3_1_OutputPaddingX_set)

# Register CImageFormatConverterParams_Params_v7_3_1 in _pylon:
_pylon.CImageFormatConverterParams_Params_v7_3_1_swigregister(CImageFormatConverterParams_Params_v7_3_1)
class ImageFormatConverterParams_Params(CImageFormatConverterParams_Params_v7_3_1):
    r"""


    Interface to image format converter parameters.  

    C++ includes: _ImageFormatConverterParams.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def _GetBaseType_AdditionalLeftShift(self):
        return _pylon.ImageFormatConverterParams_Params__GetBaseType_AdditionalLeftShift(self)

    def _Get_AdditionalLeftShift(self):
       return self._GetBaseType_AdditionalLeftShift()
    def _Set_AdditionalLeftShift(self, value):
       self._GetBaseType_AdditionalLeftShift().SetValue(value)
    AdditionalLeftShift = property(_Get_AdditionalLeftShift, _Set_AdditionalLeftShift )


    def _GetBaseType_Gamma(self):
        return _pylon.ImageFormatConverterParams_Params__GetBaseType_Gamma(self)

    def _Get_Gamma(self):
       return self._GetBaseType_Gamma()
    def _Set_Gamma(self, value):
       self._GetBaseType_Gamma().SetValue(value)
    Gamma = property(_Get_Gamma, _Set_Gamma )


    def _GetBaseType_OutputPaddingX(self):
        return _pylon.ImageFormatConverterParams_Params__GetBaseType_OutputPaddingX(self)

    def _Get_OutputPaddingX(self):
       return self._GetBaseType_OutputPaddingX()
    def _Set_OutputPaddingX(self, value):
       self._GetBaseType_OutputPaddingX().SetValue(value)
    OutputPaddingX = property(_Get_OutputPaddingX, _Set_OutputPaddingX )


    def _GetEnum_InconvertibleEdgeHandling(self):
        return _pylon.ImageFormatConverterParams_Params__GetEnum_InconvertibleEdgeHandling(self)

    def _Get_InconvertibleEdgeHandling(self):
       return self._GetEnum_InconvertibleEdgeHandling()
    def _Set_InconvertibleEdgeHandling(self, value):
       if isinstance(value, int):
        self._GetEnum_InconvertibleEdgeHandling().SetIntValue(value)
       else:
        self._GetEnum_InconvertibleEdgeHandling().SetValue(value)
    InconvertibleEdgeHandling = property(_Get_InconvertibleEdgeHandling, _Set_InconvertibleEdgeHandling )


    def _GetEnum_MonoConversionMethod(self):
        return _pylon.ImageFormatConverterParams_Params__GetEnum_MonoConversionMethod(self)

    def _Get_MonoConversionMethod(self):
       return self._GetEnum_MonoConversionMethod()
    def _Set_MonoConversionMethod(self, value):
       if isinstance(value, int):
        self._GetEnum_MonoConversionMethod().SetIntValue(value)
       else:
        self._GetEnum_MonoConversionMethod().SetValue(value)
    MonoConversionMethod = property(_Get_MonoConversionMethod, _Set_MonoConversionMethod )


    def _GetEnum_OutputBitAlignment(self):
        return _pylon.ImageFormatConverterParams_Params__GetEnum_OutputBitAlignment(self)

    def _Get_OutputBitAlignment(self):
       return self._GetEnum_OutputBitAlignment()
    def _Set_OutputBitAlignment(self, value):
       if isinstance(value, int):
        self._GetEnum_OutputBitAlignment().SetIntValue(value)
       else:
        self._GetEnum_OutputBitAlignment().SetValue(value)
    OutputBitAlignment = property(_Get_OutputBitAlignment, _Set_OutputBitAlignment )


    def _GetEnum_OutputOrientation(self):
        return _pylon.ImageFormatConverterParams_Params__GetEnum_OutputOrientation(self)

    def _Get_OutputOrientation(self):
       return self._GetEnum_OutputOrientation()
    def _Set_OutputOrientation(self, value):
       if isinstance(value, int):
        self._GetEnum_OutputOrientation().SetIntValue(value)
       else:
        self._GetEnum_OutputOrientation().SetValue(value)
    OutputOrientation = property(_Get_OutputOrientation, _Set_OutputOrientation )


# Register ImageFormatConverterParams_Params in _pylon:
_pylon.ImageFormatConverterParams_Params_swigregister(ImageFormatConverterParams_Params)
class ImageFormatConverter(ImageFormatConverterParams_Params):
    r"""


    Creates new images by converting a source image to another format.  

    Supported input image formats defined by the pixel type:  

    *   PixelType_Mono1packed  
    *   PixelType_Mono2packed  
    *   PixelType_Mono4packed  
    *   PixelType_Mono8  
    *   PixelType_Mono10  
    *   PixelType_Mono10packed  
    *   PixelType_Mono10p  
    *   PixelType_Mono12  
    *   PixelType_Mono12packed  
    *   PixelType_Mono12p  
    *   PixelType_Mono16  

    *   PixelType_BayerGR8  
    *   PixelType_BayerRG8  
    *   PixelType_BayerGB8  
    *   PixelType_BayerBG8  
    *   PixelType_BayerGR10  
    *   PixelType_BayerRG10  
    *   PixelType_BayerGB10  
    *   PixelType_BayerBG10  
    *   PixelType_BayerGR12  
    *   PixelType_BayerRG12  
    *   PixelType_BayerGB12  
    *   PixelType_BayerBG12  
    *   PixelType_BayerGR12Packed  
    *   PixelType_BayerRG12Packed  
    *   PixelType_BayerGB12Packed  
    *   PixelType_BayerBG12Packed  
    *   PixelType_BayerGR10p  
    *   PixelType_BayerRG10p  
    *   PixelType_BayerGB10p  
    *   PixelType_BayerBG10p  
    *   PixelType_BayerGR12p  
    *   PixelType_BayerRG12p  
    *   PixelType_BayerGB12p  
    *   PixelType_BayerBG12p  
    *   PixelType_BayerGR16  
    *   PixelType_BayerRG16  
    *   PixelType_BayerGB16  
    *   PixelType_BayerBG16  

    *   PixelType_RGB8packed  
    *   PixelType_BGR8packed  
    *   PixelType_RGBA8packed  
    *   PixelType_BGRA8packed  
    *   PixelType_RGB10packed  
    *   PixelType_BGR10packed  
    *   PixelType_RGB12packed  
    *   PixelType_BGR12packed  
    *   PixelType_RGB12V1packed  
    *   PixelType_RGB16packed  
    *   PixelType_RGB8planar  
    *   PixelType_RGB16planar  

    *   PixelType_YUV422packed  
    *   PixelType_YUV422_YUYV_Packed  

    Supported output image formats defined by the pixel type:  

    *   PixelType_BGRA8packed - This pixel type can be used in Windows bitmaps. See
        Pylon::SBGRA8Pixel.  
    *   PixelType_BGR8packed - This pixel type can be used in Windows bitmaps. See
        Pylon::SBGR8Pixel.  
    *   PixelType_RGB8packed - See Pylon::SRGB8Pixel.  
    *   PixelType_RGB16packed - See Pylon::SRGB16Pixel.  
    *   PixelType_RGB8planar  
    *   PixelType_RGB16planar  
    *   PixelType_Mono8  
    *   PixelType_Mono16  

    All input image formats can be converted to all output image formats.  

    RGB, BGR and Bayer image formats are converted to monochrome formats by using
    the following formula:  


    YUV formats are converted to 16 bit bit depth in an intermediate conversion
    step. This is why the output is always aligned at the most significant bit when
    converting to 16 bit color output formats like PixelType_RGB16packed.  

    par: Limitations:
        The last column of a YUV input image with odd width cannot be converted. The
        last column and the last row of a Bayer input image cannot be converted.  

    The default treatment of rows and columns that cannot be converted due to their
    location on edges, can be controlled using the
    CImageFormatConverter::InconvertibleEdgeHandling parameter. See also the
    Convert() method description.  

    The CImageFormatConverter class is not thread-safe.  

    C++ includes: ImageFormatConverter.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""


        Creates an image format converter.  

        Does not throw C++ exceptions.  

        """
        _pylon.ImageFormatConverter_swiginit(self, _pylon.new_ImageFormatConverter())
    __swig_destroy__ = _pylon.delete_ImageFormatConverter

    def Initialize(self, sourcePixelType):
        r"""


        Optionally initializes the image format converter before conversion.  

        Parameters
        ----------
        * `sourcePixelType` :  
            The pixel type of the source image.  

        *   Depending on parameter settings and the input format, data structures
            required for conversion are created, e.g. lookup tables.  
        *   Initialization is done automatically when calling Convert() if needed. This
            may add a delay when converting the first image.  

        pre:  

            *   The converter parameters are set up.  
            *   The `pixelTypeSource` must be supported by the converter.  

        Lookup tables are created when using monochrome images as input and when the
        gamma conversion method is selected or when the shift conversion method is
        selected and the value of AdditionalLeftShift is not zero. The converter can be
        reinitialized with other settings if required.  

        Throws an exception if the passed pixel type does not represent a valid input
        format. The converter object is still valid after error and can be initialized
        again.  

        """
        return _pylon.ImageFormatConverter_Initialize(self, sourcePixelType)

    def IsInitialized(self, sourcePixelType):
        r"""


        Returns information about the converter being initialized.  

        Parameters
        ----------
        * `sourcePixelType` :  
            The pixel type of the source image.  

        The result depends on the converter settings.  

        Returns
        -------
        True if initialized.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_IsInitialized(self, sourcePixelType)

    def Uninitialize(self):
        r"""


        Destroys data structures required for conversion.  

        This function can be called to free resources held by the format converter.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_Uninitialize(self)

    def GetBufferSizeForConversion(self, *args):
        r"""


        Computes the size of the destination image buffer in byte.  

        Parameters
        ----------
        * `sourceWidth` :  
            The number of pixels in a row in the source image.  
        * `sourceHeight` :  
            The number of rows in the source image.  
        * `sourcePixelType` :  
            The pixel type of the source image.  

        Returns
        -------
        The size of the destination image when converting the source image using current
        converter settings.  

        pre:  

            *   The `sourceWidth` value must be >= 0 and < _I32_MAX.  
            *   The `sourceHeight` value must be >= 0 and < _I32_MAX.  

        Throws an exception if the destination image size for the passed input cannot be
        computed. The converter object is still valid after error.  

        """
        return _pylon.ImageFormatConverter_GetBufferSizeForConversion(self, *args)

    @staticmethod
    def IsSupportedInputFormat(sourcePixelType):
        r"""


        Returns true if the image format defined by the given pixel type is a supported
        input format.  

        Parameters
        ----------
        * `sourcePixelType` :  
            The pixel type of the source image.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_IsSupportedInputFormat(sourcePixelType)

    @staticmethod
    def IsSupportedOutputFormat(destinationPixelType):
        r"""


        Returns true if the image format defined by the given pixel type is a supported
        output format.  

        Parameters
        ----------
        * `destinationPixelType` :  
            The pixel type of the destination image.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_IsSupportedOutputFormat(destinationPixelType)

    def GetNodeMap(self):
        r"""


        Provides access to the node map of the format converter.  

        Returns
        -------
        Reference to the node map of the format converter.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_GetNodeMap(self)

    def Convert(self, *args):
        r"""


        Creates a new image by converting an image to a different format.  

        The image is converted to the destination image according to the current
        converter settings. The padding area of a row in the destination image is set to
        zero.  

        Parameters
        ----------
        * `pDestinationBuffer` :  
            The pointer to the buffer of the destination image.  
        * `destinationBufferSizeBytes` :  
            The size of the buffer of the destination image.  
        * `pSourceBuffer` :  
            The pointer to the buffer of the source image.  
        * `sourceBufferSizeBytes` :  
            The size of the buffer of the source image.  
        * `sourcePixelType` :  
            The pixel type of the source image.  
        * `sourceWidth` :  
            The number of pixels in a row in the source image.  
        * `sourceHeight` :  
            The number of rows in the source image.  
        * `sourcePaddingX` :  
            The number of extra data bytes at the end of each row. The default value is
            usually 0.  
        * `sourceOrientation` :  
            The vertical orientation of the source image in the image buffer. The
            default value is usually ImageOrientation_TopDown.  

        pre:  

            *   The parameters regarding the source buffer must describe a valid image.  
            *   The format of the input image represented by the given parameter must be
                supported by the converter.  
            *   If the destination image buffer must be large enough to hold the
                destination image.  
            *   The the source buffer can not be equal the destination buffer.  

        Throws an exception if the passed parameters are not valid. The converter object
        is still valid after error.  

        """
        return _pylon.ImageFormatConverter_Convert(self, *args)

    def ImageHasDestinationFormat(self, *args):
        r"""


        Checks to see if a conversion is required or if the source image already has the
        desired format.  

        Parameters
        ----------
        * `sourcePixelType` :  
            The pixel type of the source image.  
        * `sourcePaddingX` :  
            The number of extra data bytes at the end of each row. The default value is
            usually 0.  
        * `sourceOrientation` :  
            The vertical orientation of the image in the image buffer. The default value
            is usually ImageOrientation_TopDown.  

        Returns
        -------
        Returns true if the source image already has the desired format. This is done
        according to the current converter settings.  

        A conversion may even be required image format does not change e.g. if the gamma
        conversion method is selected and the format describes a monochrome image.  

        Does not throw C++ exceptions.  

        """
        return _pylon.ImageFormatConverter_ImageHasDestinationFormat(self, *args)

    def SetOutputPixelFormat(self, pxl_fmt):
        return _pylon.ImageFormatConverter_SetOutputPixelFormat(self, pxl_fmt)

    def GetOutputPixelFormat(self):
        return _pylon.ImageFormatConverter_GetOutputPixelFormat(self)
    OutputPixelFormat = property(GetOutputPixelFormat,SetOutputPixelFormat) 

# Register ImageFormatConverter in _pylon:
_pylon.ImageFormatConverter_swigregister(ImageFormatConverter)
class FeaturePersistence(object):
    r"""


    Utility class for saving and restoring camera features to and from a file or
    string.  

    note: When saving features, the behavior of cameras supporting sequencers
        depends on the current setting of the "SequenceEnable" (some GigE models)
        or "SequencerConfigurationMode" (USB only) features respectively.  

    Only if the sequencer is in configuration mode, are the sequence sets exported.
    Otherwise, the camera features are exported without sequence sets.  

    C++ includes: FeaturePersistence.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Load(FileName, pNodeMap, validate=True):
        r"""


        Loads the features from the file to the node map.  

        Parameters
        ----------
        * `FileName` :  
            Name of the file that contains the node map values.  
        * `pNodeMap` :  
            Pointer to the node map  
        * `validate` :  
            If validate==true, all node values will be validated. In case of an error, a
            GenICam::RuntimeException will be thrown  

        Throws an exception if loading fails.  

        """
        return _pylon.FeaturePersistence_Load(FileName, pNodeMap, validate)

    @staticmethod
    def Save(FileName, pNodeMap):
        r"""


        Saves the node map to the file.  

        Sequence sets of a camera are automatically saved if SequenceEnable or
        SequencerConfigurationMode is enabled.  

        Parameters
        ----------
        * `FileName` :  
            Name of the file that contains the node map values  
        * `pNodeMap` :  
            Pointer to the node map  

        Throws an exception if saving fails.  

        """
        return _pylon.FeaturePersistence_Save(FileName, pNodeMap)

    @staticmethod
    def LoadFromString(Features, pNodeMap, validate=True):
        r"""


        Loads the features from the string to the node map.  

        Parameters
        ----------
        * `Features` :  
            String containing the node map values.  
        * `pNodeMap` :  
            Pointer to the node map.  
        * `validate` :  
            If validate==true, all node values will be validated. In case of an error, a
            GenICam::RuntimeException will be thrown.  

        Throws an exception if loading fails.  

        """
        return _pylon.FeaturePersistence_LoadFromString(Features, pNodeMap, validate)

    @staticmethod
    def SaveToString(pNodeMap):
        r"""


        Saves the node map to the string. Sequence sets of a camera are automatically
        saved, if SequenceEnable or SequencerConfigurationMode is enabled.  

        Parameters
        ----------
        * `Features` :  
            String containing the node map values  
        * `pNodeMap` :  
            Pointer to the node map  

        Throws an exception if saving fails.  

        """
        return _pylon.FeaturePersistence_SaveToString(pNodeMap)

# Register FeaturePersistence in _pylon:
_pylon.FeaturePersistence_swigregister(FeaturePersistence)
CompressionStatus_Ok = _pylon.CompressionStatus_Ok
CompressionStatus_BufferOverflow = _pylon.CompressionStatus_BufferOverflow
CompressionStatus_Error = _pylon.CompressionStatus_Error
Endianness_Little = _pylon.Endianness_Little
Endianness_Big = _pylon.Endianness_Big
Endianness_Auto = _pylon.Endianness_Auto
class CompressionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hasCompressedImage = property(_pylon.CompressionInfo_hasCompressedImage_get, _pylon.CompressionInfo_hasCompressedImage_set)
    compressionStatus = property(_pylon.CompressionInfo_compressionStatus_get, _pylon.CompressionInfo_compressionStatus_set)
    lossy = property(_pylon.CompressionInfo_lossy_get, _pylon.CompressionInfo_lossy_set)
    pixelType = property(_pylon.CompressionInfo_pixelType_get, _pylon.CompressionInfo_pixelType_set)
    width = property(_pylon.CompressionInfo_width_get, _pylon.CompressionInfo_width_set)
    height = property(_pylon.CompressionInfo_height_get, _pylon.CompressionInfo_height_set)
    offsetX = property(_pylon.CompressionInfo_offsetX_get, _pylon.CompressionInfo_offsetX_set)
    offsetY = property(_pylon.CompressionInfo_offsetY_get, _pylon.CompressionInfo_offsetY_set)
    paddingX = property(_pylon.CompressionInfo_paddingX_get, _pylon.CompressionInfo_paddingX_set)
    paddingY = property(_pylon.CompressionInfo_paddingY_get, _pylon.CompressionInfo_paddingY_set)
    decompressedImageSize = property(_pylon.CompressionInfo_decompressedImageSize_get, _pylon.CompressionInfo_decompressedImageSize_set)
    decompressedPayloadSize = property(_pylon.CompressionInfo_decompressedPayloadSize_get, _pylon.CompressionInfo_decompressedPayloadSize_set)

    def __init__(self):
        _pylon.CompressionInfo_swiginit(self, _pylon.new_CompressionInfo())

    def to_dict(self):
        return {
            "hasCompressedImage": self.hasCompressedImage,
            "compressionStatus": self.compressionStatus,
            "lossy": self.lossy,
            "pixelType": self.pixelType,
            "width": self.width,
            "height": self.height,
            "offsetX": self.offsetX,
            "offsetY": self.offsetY,
            "paddingX": self.paddingX,
            "paddingY": self.paddingY,
            "decompressedImageSize": self.decompressedImageSize,
            "decompressedPayloadSize": self.decompressedPayloadSize,
        }

    def __repr__(self):
        return "<CompressionInfo " + repr(self.to_dict()) + ">"

    __swig_destroy__ = _pylon.delete_CompressionInfo

# Register CompressionInfo in _pylon:
_pylon.CompressionInfo_swigregister(CompressionInfo)
CompressionMode_Off = _pylon.CompressionMode_Off
CompressionMode_BaslerLossless = _pylon.CompressionMode_BaslerLossless
CompressionMode_BaslerFixRatio = _pylon.CompressionMode_BaslerFixRatio
class ImageDecompressor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pylon.ImageDecompressor_swiginit(self, _pylon.new_ImageDecompressor(*args))
    __swig_destroy__ = _pylon.delete_ImageDecompressor

    def HasCompressionDescriptor(self):
        return _pylon.ImageDecompressor_HasCompressionDescriptor(self)

    def ResetCompressionDescriptor(self):
        return _pylon.ImageDecompressor_ResetCompressionDescriptor(self)

    def __eq__(self, imageDecompressor):
        return _pylon.ImageDecompressor___eq__(self, imageDecompressor)

    def SetCompressionDescriptor(self, pCompressionDescriptor):
        return _pylon.ImageDecompressor_SetCompressionDescriptor(self, pCompressionDescriptor)

    def GetCompressionInfo(self, *args):
        return _pylon.ImageDecompressor_GetCompressionInfo(self, *args)

    def ComputeCompressionDescriptorHash(self, pCompressionDescriptor):
        return _pylon.ImageDecompressor_ComputeCompressionDescriptorHash(self, pCompressionDescriptor)

    def GetCurrentCompressionDescriptorHash(self):
        return _pylon.ImageDecompressor_GetCurrentCompressionDescriptorHash(self)

    def GetCompressionDescriptorHash(self, *args):
        return _pylon.ImageDecompressor_GetCompressionDescriptorHash(self, *args)

    def DecompressImage(self, *args):
        return _pylon.ImageDecompressor_DecompressImage(self, *args)

# Register ImageDecompressor in _pylon:
_pylon.ImageDecompressor_swigregister(ImageDecompressor)

from contextlib import contextmanager
import sys

ComponentType_Undefined = _pylon.ComponentType_Undefined
ComponentType_Intensity = _pylon.ComponentType_Intensity
ComponentType_Range = _pylon.ComponentType_Range
ComponentType_Confidence = _pylon.ComponentType_Confidence
class PylonDataComponent(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pylon.PylonDataComponent_swiginit(self, _pylon.new_PylonDataComponent(*args))
    __swig_destroy__ = _pylon.delete_PylonDataComponent

    def IsValid(self):
        return _pylon.PylonDataComponent_IsValid(self)

    def GetComponentType(self):
        return _pylon.PylonDataComponent_GetComponentType(self)

    def GetPixelType(self):
        return _pylon.PylonDataComponent_GetPixelType(self)

    def GetWidth(self):
        return _pylon.PylonDataComponent_GetWidth(self)

    def GetHeight(self):
        return _pylon.PylonDataComponent_GetHeight(self)

    def GetOffsetX(self):
        return _pylon.PylonDataComponent_GetOffsetX(self)

    def GetOffsetY(self):
        return _pylon.PylonDataComponent_GetOffsetY(self)

    def GetPaddingX(self):
        return _pylon.PylonDataComponent_GetPaddingX(self)

    def GetDataSize(self):
        return _pylon.PylonDataComponent_GetDataSize(self)

    def GetTimeStamp(self):
        return _pylon.PylonDataComponent_GetTimeStamp(self)

    def GetStride(self, strideBytes):
        return _pylon.PylonDataComponent_GetStride(self, strideBytes)

    @needs_numpy
    def GetImageFormat(self, pt = None):
        if pt is None:
            pt = self.GetPixelType()
        if IsPacked(pt):
            raise ValueError("Packed Formats are not supported with numpy interface")
        if pt in ( PixelType_Mono8, PixelType_BayerGR8, PixelType_BayerRG8, PixelType_BayerGB8, PixelType_BayerBG8, PixelType_Confidence8, PixelType_Coord3D_C8 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "B"
            dtype = _pylon_numpy.uint8
        elif pt in ( PixelType_Mono10, PixelType_BayerGR10, PixelType_BayerRG10, PixelType_BayerGB10, PixelType_BayerBG10 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono12, PixelType_BayerGR12, PixelType_BayerRG12, PixelType_BayerGB12, PixelType_BayerBG12 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_Mono16, PixelType_BayerGR16, PixelType_BayerRG16, PixelType_BayerGB16, PixelType_BayerBG16, PixelType_Confidence16, PixelType_Coord3D_C16 ):
            shape = (self.GetHeight(), self.GetWidth())
            format = "H"
            dtype = _pylon_numpy.uint16
        elif pt in ( PixelType_RGB8packed, PixelType_BGR8packed ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_YUV422_YUYV_Packed, PixelType_YUV422packed ):
            shape = (self.GetHeight(), self.GetWidth(), 2)
            dtype = _pylon_numpy.uint8
            format = "B"
        elif pt in ( PixelType_Coord3D_ABC32f, ):
            shape = (self.GetHeight(), self.GetWidth(), 3)
            dtype = _pylon_numpy.float32
            format = "f"
        else:
            raise ValueError("Pixel format currently not supported")

        return (shape, dtype, format)

    @needs_numpy
    def GetArray(self, raw = False):

    # Raw case => Simple byte wrapping of buffer
        if raw:
            shape, dtype, format = ( self.GetDataSize() ), _pylon_numpy.uint8, "B"
            buf = self.GetData()
            return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

        pt = self.GetPixelType()
        if IsPacked(pt):
            buf, new_pt = self._Unpack10or12BitPacked()
            shape, dtype, format = self.GetImageFormat(new_pt)
        else:
            shape, dtype, format = self.GetImageFormat(pt)
            buf = self.GetData()

    # Now we will copy the data into an array:
        return _pylon_numpy.ndarray(shape, dtype = dtype, buffer=buf)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.Release()

    @contextmanager
    @needs_numpy
    def GetArrayZeroCopy(self, raw = False):
        '''
        Get a numpy array for the image buffer as zero copy reference to the underlying buffer.
        Note: The context manager variable MUST be released before leaving the scope.
        '''

    # For packed formats, we cannot zero-copy, so use GetArray
        pt = self.GetPixelType()
        if IsPacked(pt):
            yield self.GetArray()
            return

        mv = self.GetMemoryView()
        if not raw:
            shape, dtype, format = self.GetImageFormat()
            mv = mv.cast(format, shape)

        ar = _pylon_numpy.asarray(mv)

    # trace external references to array
        initial_refcount = sys.getrefcount(ar)

    # yield the array to the context code
        yield ar

    # detect if more refs than the one from the yield are held
        if sys.getrefcount(ar) > initial_refcount + 1:
            raise RuntimeError("Please remove any references to the array before leaving context manager scope!!!")

    # release the memory view
        mv.release()


    def Release(self):
        return _pylon.PylonDataComponent_Release(self)

    def GetData(self):
        return _pylon.PylonDataComponent_GetData(self)

    def GetMemoryView(self):
        return _pylon.PylonDataComponent_GetMemoryView(self)

    def _Unpack10or12BitPacked(self):
        return _pylon.PylonDataComponent__Unpack10or12BitPacked(self)

# Register PylonDataComponent in _pylon:
_pylon.PylonDataComponent_swigregister(PylonDataComponent)
class PylonDataContainer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pylon.PylonDataContainer_swiginit(self, _pylon.new_PylonDataContainer(*args))
    __swig_destroy__ = _pylon.delete_PylonDataContainer

    def GetDataComponentCount(self):
        return _pylon.PylonDataContainer_GetDataComponentCount(self)

    def GetDataComponent(self, index):
        return _pylon.PylonDataContainer_GetDataComponent(self, index)

    def Save(self, filename):
        return _pylon.PylonDataContainer_Save(self, filename)

    def Load(self, filename):
        return _pylon.PylonDataContainer_Load(self, filename)

    def Release(self):
        return _pylon.PylonDataContainer_Release(self)

# Register PylonDataContainer in _pylon:
_pylon.PylonDataContainer_swigregister(PylonDataContainer)
PylonDataContainer.DataComponentCount = property(PylonDataContainer.GetDataComponentCount) 
PylonDataComponent.ComponentType = property(PylonDataComponent.GetComponentType) 
PylonDataComponent.PixelType = property(PylonDataComponent.GetPixelType) 
PylonDataComponent.Width = property(PylonDataComponent.GetWidth) 
PylonDataComponent.Height = property(PylonDataComponent.GetHeight) 
PylonDataComponent.OffsetX = property(PylonDataComponent.GetOffsetX) 
PylonDataComponent.OffsetY = property(PylonDataComponent.GetOffsetY) 
PylonDataComponent.PaddingX = property(PylonDataComponent.GetPaddingX) 
PylonDataComponent.Data = property(PylonDataComponent.GetData) 
PylonDataComponent.DataSize = property(PylonDataComponent.GetDataSize) 
PylonDataComponent.TimeStamp = property(PylonDataComponent.GetTimeStamp) 
PylonDataComponent.Array = property(PylonDataComponent.GetArray) 
PylonDataComponent.ImageFormat = property(PylonDataComponent.GetImageFormat) 
GrabResult.ErrorDescription = property(GrabResult.GetErrorDescription) 
GrabResult.ErrorCode = property(GrabResult.GetErrorCode) 
GrabResult.PayloadType = property(GrabResult.GetPayloadType) 
GrabResult.PixelType = property(GrabResult.GetPixelType) 
GrabResult.Width = property(GrabResult.GetWidth) 
GrabResult.Height = property(GrabResult.GetHeight) 
GrabResult.OffsetX = property(GrabResult.GetOffsetX) 
GrabResult.OffsetY = property(GrabResult.GetOffsetY) 
GrabResult.PaddingX = property(GrabResult.GetPaddingX) 
GrabResult.PaddingY = property(GrabResult.GetPaddingY) 
GrabResult.Buffer = property(GrabResult.GetBuffer) 
GrabResult.Array = property(GrabResult.GetArray) 
GrabResult.PayloadSize = property(GrabResult.GetPayloadSize) 
GrabResult.BlockID = property(GrabResult.GetBlockID) 
GrabResult.TimeStamp = property(GrabResult.GetTimeStamp) 
GrabResult.ImageSize = property(GrabResult.GetImageSize) 
GrabResult.ID = property(GrabResult.GetID) 
GrabResult.ImageNumber = property(GrabResult.GetImageNumber) 
GrabResult.NumberOfSkippedImages = property(GrabResult.GetNumberOfSkippedImages) 
GrabResult.ChunkDataNodeMap = property(GrabResult.GetChunkDataNodeMap) 
GrabResult.DataComponentCount = property(GrabResult.GetDataComponentCount) 
GrabResult.DataContainer = property(GrabResult.GetDataContainer) 
PylonImage.AllocatedBufferSize = property(PylonImage.GetAllocatedBufferSize) 
PylonImage.Aoi = property(PylonImage.GetAoi) 
PylonImage.Array = property(PylonImage.GetArray) 
PylonImage.Buffer = property(PylonImage.GetBuffer) 
PylonImage.Height = property(PylonImage.GetHeight) 
PylonImage.ImageFormat = property(PylonImage.GetImageFormat) 
PylonImage.ImageSize = property(PylonImage.GetImageSize) 
PylonImage.Orientation = property(PylonImage.GetOrientation) 
PylonImage.PaddingX = property(PylonImage.GetPaddingX) 
PylonImage.PixelData = property(PylonImage.GetPixelData) 
PylonImage.PixelType = property(PylonImage.GetPixelType) 
PylonImage.Plane = property(PylonImage.GetPlane) 
PylonImage.Stride = property(PylonImage.GetStride) 
PylonImage.Width = property(PylonImage.GetWidth) 

def GetPylonVersion():
    return _pylon.GetPylonVersion()

def GetPylonVersionString():
    return _pylon.GetPylonVersionString()


__version__ = '4.1.0'
